<!-- build time:Mon Jul 09 2018 10:27:30 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="boxi"><meta name="google-site-verification" content="iOm73y6vS5qme_s6tWGOVE1l5iATBiNi7Ye7J4dv68g"><meta name="baidu-site-verification" content="9BXA7j00i6"><title>Vue 浅析与实践 · boxi's box</title><meta name="description" content="Vue简介众所周知，如今的前端框架/解决方案数不胜数，从最初的Backbone，到Angular和Meteor等，这当中有很多都为前端的工程化管理和建设提供了一整套解决方案，是一种“大”框架，但这样的框架往往具备一定的排它性，使得开发的自由和灵活度受到限制。与此不同的是，Vue对自己的定位是一个渐进"><meta name="keywords" content="技术积累, 生活感悟"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/img/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/img/logo@2x.png" style="width:150px"><h3><a href="/">boxi's box</a></h3><div class="description"><p>Poor Guy In Shenzhen</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2263667870"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/boxi.zeng"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/boxizen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me">CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben </a><span>Edit by</span><a href="https://github.com/boxizen"> Boxi</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Vue 浅析与实践</a></h3></div><div class="post-content"><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><img src="/img/posts/vue/1502722589_86_w1496_h422.png" alt="vue 2.0"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>众所周知，如今的前端框架/解决方案数不胜数，从最初的Backbone，到Angular和Meteor等，这当中有很多都为前端的工程化管理和建设提供了一整套解决方案，是一种“大”框架，但这样的框架往往具备一定的排它性，使得开发的自由和灵活度受到限制。</p><p>与此不同的是，Vue对自己的定位是一个渐进式的JavaScript框架，它最核心的部分是只是为了解决视图层方面的问题，提供<strong>声明式渲染</strong>和<strong>组件化</strong>管理模式。同时对于路由管理、状态管理和构建工作方面又有自己的解决方案，开发者可以自由地选择或者组合，从而能够更加灵活自如地进行项目开发。</p><h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><p><del>手动改变DOM操作是件损耗性能的事情，</del>几乎所有MVX框架都遵循一个原则：视图的状态应该由数据描述，并且通过数据驱动变化。</p><p><img src="/img/posts/vue/1503133912_12_w2016_h642.png" alt="双向数据绑定"></p><p>Vue采用发布者-订阅者模式实现双向数据绑定，首先Vue将会获取到需要监听的对象的所有属性，通过 <strong>Object.defineProperty</strong> 方法完成对象属性的劫持，将其转化为getter和setter，当属性被访问或修改时，立即将变化通知给订阅者，并由订阅者完成相应的逻辑操作，主要流程下图所示。</p><p><img src="/img/posts/vue/1503216087_83_w2126_h1182.jpeg" alt="响应式原理"></p><p>整个过程中主要涉及了 Observer、Dep 和 Watcher三个类，相关源码(已精简)如下：</p><p><strong>Observer:</strong></p><p>主要处理属性监听逻辑，将监听属性转化为get/set属性，当属性被访问时，调用dep.depend() 方法，而属性被修改时，则调用了dep.notify()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 监听属性的get和set方法</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">   val = newVal</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dep:</strong></p><p>担任发布者的角色，维护订阅者列表，负责订阅者的添加和通知工作，上面所提到的depend()和notify()方法在这里实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  id: number;</span><br><span class="line">  <span class="comment">// 订阅者列表</span></span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 属性被访问时调用该方法，</span></span><br><span class="line"> <span class="comment">// 通知依赖的目标（即订阅者）添加该依赖，</span></span><br><span class="line">  <span class="comment">// 同时将其加入订阅者列表中</span></span><br><span class="line"> <span class="comment">// (调用addSub()方法)</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当监听到依赖的属性发生改变时，</span></span><br><span class="line"> <span class="comment">// 通知订阅者执行状态更新操作</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Watcher:</strong></p><p>担任订阅者角色，即上述代码中的 Dep.target，可以订阅多个Dep，在每次收到发布者消息通知时触发update()方法执行更新逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: ISet;</span><br><span class="line">  newDepIds: ISet;	  </span><br><span class="line">  <span class="comment">// 为该指令添加依赖（发布者）</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新视图逻辑，依赖的属性值发生改变时触发</span></span><br><span class="line">  update () &#123;</span><br><span class="line"> <span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>过去为了实现父子组件或者平行组件的数据通信，常见的做法是直接或间接地使用 <strong>props</strong> 属性和 <strong>emit()</strong> 方法来实现，这样的做法耦合度强，且难以应付复杂场景下的状态管理。</p><p><strong>Vuex</strong> 的出现可以很好地规避此类问题，它是一种Vue应用的专用状态管理模式，负责集中式地存储和管理整个Vue应用程序的组件状态，实现更好的状态共享。Vuex将组件状态的存储和管理放在了 <strong>Store</strong> 里面，并为其提供了4种特性，分别是 <strong>state</strong>、<strong>actions</strong>、<strong>mutations</strong> 和 <strong>getters</strong>：</p><ul><li><strong>state</strong>，作为驱动应用的数据源，保存了组件的各种状态；</li><li><strong>mutations</strong>，类似于事件，是改变 state 的唯一入口，且里面的操作必须是同步的；</li><li><strong>actions</strong>，类似于 mutations，里面可以进行一些如 ajax 请求等异步的逻辑操作，但如果想对 state 的状态进行修改，必须通过 mutaions 完成；</li><li><strong>getters</strong>，可以对 state 进行某些处理动作，并对处理后的结果提供访问接口。</li></ul><p><img src="/img/posts/vue/1503241390_97_w1894_h968.jpeg" alt="vuex状态管理"></p><p><strong>Vuex</strong>状态管理流程如上图所示，主要分为如下四个步骤：</p><ul><li>视图层中的 <strong>Components</strong> 通过 <strong>this.$store.xxx</strong> 或 <strong>getters</strong> 方法从 <strong>state</strong> 中获取数据并渲染；</li><li>用户在 <strong>Components</strong> 中执行某些动作（如点击按钮fetch数据）时，通过调用 <strong>dispatch()</strong> 方法将执行动作的指令发送到 <strong>Actions</strong> 中对应的方法；</li><li><strong>Actions</strong> 解析请求指令，完成相应的逻辑（如ajax数据请求），并在最后(ajax请求结束后)通过 <strong>commit()</strong> 方法通知 <strong>mutations</strong> 对 <strong>state</strong> 状态进行修改；</li><li><strong>Mutations</strong> 收到 <strong>commit</strong> 请求后，对 <strong>state</strong> 进行赋值操作，以完成数据的修改。</li></ul><p><img src="/img/posts/vue/1503286605_12_w1098_h720.png" alt="vue devtools"></p><p>对于开发过程中 Vuex 状态的追踪，可以通过 Vue Devtools 的 “Vuex” 一栏进行查看，如上图所示，安装方法可以自行搜索。</p><h1 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h1><p><img src="/img/posts/vue/1503302982_86_w1320_h252.png" alt="K歌erp"></p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>全民K歌初期在试水麦克风售卖活动中取得了良好的市场反馈，为继续推动周边实体的售卖，现在期望搭建一个属于自己的售卖平台。整个需求分为H5和PC两部分，其中H5为用户购买实体周边的入口，PC则是对用户的订单数据进行管理。本项目为需求中的PC部分，共由订单数据概览、待审核、待发货、已发货和退换货五页组成。</p><p><img src="/img/posts/vue/1503305805_18_w1200_h800.jpg" alt="项目页面"></p><p>页面具体介绍如下：</p><ul><li><strong>概览页</strong>，包含了整个平台上的交易数据，货品的实时库存以及当前用户的待办事项；</li><li><strong>待审核</strong>，显示最新的订单数据，用户可以在该页中执行订单审核动作；</li><li><strong>待发货</strong>，已经通过审核的订单将会移动至该页，该页为管理员提供了物流信息导入和已经确认发货的动作；</li><li><strong>已发货</strong>，显示已经发货的订单列表，用户可以对发货的地址进行修改，同时也可以执行申请退款的操作；</li><li><strong>退换货</strong>，包含了“待处理“、“”已通过“和“已拒绝”的tab页。其中待处理tab显示了前端发起退货或erp上执行“申请退款“的订单列表，而用户在该列表中执行的动作(允许/拒绝退款)将会使数据移至“”已通过“或“已拒绝”的列表中。</li></ul><p>此外，对于所有的列表页，需要提供批量操作，如批量审核、发货退款和物流信息导入等，并提供分页操作。同时登陆需要通过K歌扫码完成，所有的CGI调用需要在K歌的登陆态下进行。</p><h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><p>项目的构建使用 <code>vue-cli</code> 完成，具体操作流程如下：</p><p><img src="/img/posts/vue/1503301649_26_w877_h484.png" alt="vue-cli构建项目"></p><p>由于公司网络原因，在执行 <strong>vue-init webpack [project-name]</strong> 时会出现无法下载模板库的错误，详情请见<a href="http://km.oa.com/q/view/152812" target="_blank" rel="noopener">此处</a>，解决办法可以是通过设置如图中所示的 npm 代理，或者是直接下载 vue 模板中的<a href="https://github.com/vuejs-templates/webpack/tree/master/template" target="_blank" rel="noopener">wepack库</a>并在本地运行完成。</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><p><img src="/img/posts/vue/1503327316_89_w1300_h231.png" alt="开发实践"></p><p><strong>(1) 目录规划</strong></p><p>本文针对 <code>vue-cli</code> 构建出的项目进行结构上的调整，最终得出如下所示的目录结构：</p><p><img src="/img/posts/vue/1503317713_33_w1530_h1146.png" alt="项目目录结构"></p><p>如上图，client目录为客户端的主要开发目录，主要包含了程序入口文件 <strong>app.js</strong>、客户端路由文件 <strong>router</strong>、客户端视图曾<strong>view</strong>、组件模块<strong>components</strong>和应用状态管理层(即Vuex)<strong>Store</strong>。</p><p><strong>(2) Vuex规范</strong></p><p>前面已经提到，订单相关的页面共有四页，对应着待审核、待发货、已发货和退换货四种状态，由于每种状态的相关操作逻辑不同，在开发过程中将Store中的order模块划分为review、ship、completed和refund四个子模块。下面代码展示了一个简化的review子模块的代码，其他模块的代码与之类似，都包含了 <strong>state</strong>、<strong>mutations</strong>、<strong>getters</strong>和<strong>actions</strong>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/modules/order/review/index.js</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">     re_order_data: &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">     [types.GET_RE_ORDER_LIST] (state, data) &#123;</span><br><span class="line">       state.re_order_data = data</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> getters = &#123;</span><br><span class="line">     re_order_list: <span class="function"><span class="params">state</span> =&gt;</span> state.re_order_list</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> actions = &#123;</span><br><span class="line">     getReOrderList (&#123;commit , state, rootState&#125;, params) &#123;</span><br><span class="line">       common.ajax(&#123;</span><br><span class="line">         url: orderList,</span><br><span class="line">         data:&#123;</span><br><span class="line">           type: <span class="number">5</span>,</span><br><span class="line">           filter_by: STATUS_HAVE_PAY</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;).always(<span class="function"><span class="params">res</span> =&gt;</span> &#123;      </span><br><span class="line">         commit(<span class="string">'GET_RE_ORDER_LIST'</span>, res.data)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">     state,</span><br><span class="line">     mutations,</span><br><span class="line">     getters,</span><br><span class="line">     actions</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此时你也许注意到，Store被划分成多个模块，而每个模块里面可能又会有更细粒度的划分。在实际的运行过程中，需要对这些模块进行整合，这里需要用到Vuex提供的modules属性，相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'./modules/app'</span></span><br><span class="line"><span class="keyword">import</span> menu <span class="keyword">from</span> <span class="string">'./modules/menu'</span></span><br><span class="line"><span class="keyword">import</span> order <span class="keyword">from</span> <span class="string">'./modules/order'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    app,</span><br><span class="line">    menu,</span><br><span class="line">    ...order</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>(3) 组件调用</strong></p><p>组件对Vuex中state状态的调用逻辑通常是放在 <strong>data</strong> 或 <strong>computed</strong> 属性中，但需要注意的是，如果期望得到的是响应式的数据，则必须将调用逻辑放在计算属性 <strong>computed</strong> 中，这样当每次state状态发生变化时，<strong>computed</strong> 属性中的数据都会被重新计算，同时重新触发更新视图。此外组件也可以直接调用Vuex中的mutations和actions事件，这通常放在<strong>methods</strong>属性中进行。</p><p><strong>(4) 其他</strong></p><p><strong>路由处理</strong>，对于一个单页应用，自然少不了路由处理，项目的路由使用官方的vue-router处理，使用<code>router.beforeEach()</code>方法在每次路由跳转前进行拦截，判断用户是否登录，如没有登录则跳转至登录页。</p><p><strong>网络请求</strong>，Vue 2.0开始不再维护 vue-resourse，转而推荐 <strong>axios</strong> 作为标准的网络请求库，但是由于 <strong>axios</strong> 不支持 <strong>jsonp</strong> 跨域方式，遂放弃，在项目中使用了团队的 ajax 模块。</p><p><strong>延迟加载</strong>，项目使用了webpack作为打包构建工具，打包结束后默认情况下会产生两个js文件：app.js和vendor.js，而项目在一开始就已经加载了这两个js文件，如果要想实现路由的延迟加载，需要将路由请求的组件定位为<strong>异步组件</strong>，并结合webpack的代码分割特性实现，方法是通过 <code>require.ensure</code> 的方式引入组件。</p><h1 id="最后说句"><a href="#最后说句" class="headerlink" title="最后说句"></a>最后说句</h1><p>本篇文章前半部分对 vue2.0 进行了浅析：分析关于响应式方面的源码，了解具体的实现原理与模式，并对Vuex 数据管理做了知识梳理与流程说明。后半部分则是在项目中应用了 Vue 的技术栈，并对实践过程中的代码细节和关键点做了总结。</p><p>在整个开发过程中，能够较为深刻地体会到vue对于代码编写的舒适性(来自于组件化的管理方式)以及vuex对于代码组织方面的优雅。另外由于时间上的关系（实际上是因为懒）， 还没有仔细了解关于Vue 渲染方面的原理，希望可以找个时间在后续补上这部分内容。</p><p>谢谢阅读，欢迎指正 (=^_^=)</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zhihu.com/question/51907207" target="_blank" rel="noopener">Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？</a></li><li><a href="http://www.infoq.com/cn/articles/vue-2-progressive-front-end-solution/" target="_blank" rel="noopener">Vue 2.0——渐进式前端解决方案</a></li><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入Vue 2,0响应式原理</a></li><li><a href="https://github.com/vuejs/vue/tree/dev/src/core/observer" target="_blank" rel="noopener">Vue observer源码</a></li></ul></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-22</span><i class="fa fa-tag"></i><a class="tag" href="/categories/前端/" title="前端">前端 </a><a class="tag" href="/tags/VueJS/" title="VueJS">VueJS</a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2017/08/22/vue_erp/,boxi's box,Vue 浅析与实践,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/12/07/spider/" title="所见即所得，可视化爬虫实践">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/09/11/electron/" title="Electron 构建跨平台桌面应用">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine=new Valine({el:"#vcomments",notify:!0,verify:!1,app_id:"bUTfY8SwOBitSS8uqiV0vG0I-gzGzoHsz",app_key:"N6bRxFzuVXEBBdX96fGb1i4e",placeholder:"来，一起快活",path:window.location.pathname,avatar:"monsterid"})</script></div></div></div></div><script src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1274080808'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s13.cnzz.com/z_stat.php%3Fid%3D1274080808%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">var ifm=document.getElementById("iframe");ifm&&($(window).width()>500?ifm.height=document.documentElement.clientHeight-250||400:ifm.height=200)</script></body></html><!-- rebuild by neat -->