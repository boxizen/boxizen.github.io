<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boxi&#39;s box</title>
  
  <subtitle>超人的世界需要一丝安慰</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://boxizen.github.io/"/>
  <updated>2018-07-08T10:50:06.452Z</updated>
  <id>https://boxizen.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>管理系统配置化实践</title>
    <link href="https://boxizen.github.io/2018/07/07/kube_lego/"/>
    <id>https://boxizen.github.io/2018/07/07/kube_lego/</id>
    <published>2018-07-06T16:00:00.000Z</published>
    <updated>2018-07-08T10:50:06.452Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>接触过管理系统研发的同学都知道，此类需求其实相差无几，如何在这方面减少重复劳动，提高工作效率，无论是对自己还是团队都是一件有益的事情。</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着K歌业务扩张，数据流不断增长，各种管理系统需求应运而生，给Web团队造成了较大的人力和时间消耗。还记得刚入职满半年的时候，自己手头上接到的管理系统需求就已经有四五个，而来来去去无非是一些增删改查操作，区别仅仅是交互上的些许差异。</p><p>为了减少团队在重复劳动中的输出，团队于四月份敲定并着手开发一套适用于自身业务的通用管理系统搭建平台（<strong>kube</strong>）。</p><h1 id="kube-lego"><a href="#kube-lego" class="headerlink" title="kube lego"></a>kube lego</h1><p><img src="/img/posts/kube/1530853829_69.png" alt="kube lego 通用管理系统"></p><p><strong>kube lego</strong> 是 <strong>kube</strong> ( K歌通用管理系统搭建平台 ) 中的一个子系统，用于快速构建管理系统的前端，目标是期望以如下图所示的一种配置的方式构建出管理系统中的每一个组件部位，组件的数据状态以及组件之间的事件交互等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"mode"</span>: <span class="string">"tabke"</span>, <span class="comment">// 组件类型</span></span><br><span class="line">  <span class="string">"modeid"</span>: <span class="string">"xxx"</span>, <span class="comment">// 唯一标识</span></span><br><span class="line">  <span class="string">"style"</span>: &#123;...&#125;,  <span class="comment">// 样式表</span></span><br><span class="line">  <span class="string">"event"</span>: &#123;...&#125;,  <span class="comment">// 请求事件类型</span></span><br><span class="line">  <span class="string">"data"</span>: &#123;...&#125;    <span class="comment">// 组件所维护的数据对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个组件就像一个乐高积木，搭建系统的过程就像拼装积木一样把一个个组件组合在一起，这是 <strong>kube lego</strong> 命名之意。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/img/posts/kube/1530938734_5.png" alt="技术实践"><br>在调研并参考了公司内外的相关实践后，最终决定以 <strong>Vue</strong> 语言，<strong>Element UI</strong> 框架和 <strong>JSON</strong> 配置载体作为 <strong>kube lego</strong> 的实践基础。</p><blockquote><p><strong>PS:</strong> 实际上这里的配置载体不算是严格的<strong>JSON</strong>，因为有些情况下需要配置<strong>function</strong>应对复杂或自定义的事件处理</p></blockquote><h3 id="组件加载"><a href="#组件加载" class="headerlink" title="组件加载"></a>组件加载</h3><p>由于系统是在运行时通过读取JSONMAP配置的方式完成组件的加载与渲染，所以要使用的组件都需要事先定义好且完成全局注册。对于组件的动态加载，可通过 <strong>Vue</strong> 的 <strong>is</strong> 关键词实现：<br><img src="/img/posts/kube/1530931979_61.png" alt="is 关键词"><br>组件加载渲染流程如下图所示，图左侧为JSON配置，图中是系统通过 <strong>is</strong> 关键词动态读取配置中的组件类型，并将配置中数据传递给该组件，最终生成右侧的组件。<br><img src="/img/posts/kube/1530932812_32.png" alt="组件动态加载"></p><h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><p>一般情况我们认为系统中的组件可分为 <strong>平行组件</strong> 和 <strong>嵌套组件</strong> 两种。而 <strong>嵌套组件</strong> 实际又可以分为天然的父子嵌套和自定义的布局嵌套，如像表单与文本输入框这种属于天然的父子嵌套关系，这里我们通过在 <strong>Form</strong> 表单组件中加入 <strong>content</strong> 属性来指定文本框、下拉框这些表单子组件，定义与解析方法如下：<br><img src="/img/posts/kube/1530935191_84.png" alt="父子组件嵌套"><br>另一种是自定义的布局嵌套，一般发生于如 <strong>Page页面</strong>、<strong>Dialog弹窗</strong> 和 <strong>Collapse折叠面板</strong> 等容器组件中，这里我们的做法是在这些容器组件中引入 <strong>layout</strong> 和 <strong>component</strong> 属性指定容器里组件的排列与布局：</p><blockquote><p>此处的 <strong>layout</strong> 属性复用了 <strong>elementUI</strong> 的<a href="http://element-cn.eleme.io/#/zh-CN/component/layout" target="_blank" rel="noopener">24分栏布局</a>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"mode"</span>: <span class="string">"EDialog"</span>,</span><br><span class="line">  <span class="string">"layout"</span>: &#123;</span><br><span class="line">     <span class="string">"gutter"</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="string">"rows"</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="string">"cols"</span>: [</span><br><span class="line">           &#123; <span class="string">"span"</span>: <span class="number">12</span>, <span class="string">"modeid"</span>: <span class="string">"sTable"</span>&#125;,</span><br><span class="line">           &#123; <span class="string">"span"</span>: <span class="number">12</span>, <span class="string">"modeid"</span>: <span class="string">"sForm"</span>&#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"components"</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="string">"mode"</span>: <span class="string">"ETable"</span>,</span><br><span class="line">       <span class="string">"modeid"</span>: <span class="string">"sTable"</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="string">"mode"</span>: <span class="string">"EForm"</span>,</span><br><span class="line">       <span class="string">"modeid"</span>: <span class="string">"sTable"</span>,      </span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>上面提到组件有 <strong>父子组件</strong> 和 <strong>平行组件</strong> 两类。对于父子组件的通信，可通过结合使用 <strong>props</strong>属性 、 <strong>emit</strong> 方法 和 <strong>watch</strong> 钩子的方式进行，此处略过。对于平行组件而言，我们结合了 <strong>vuex</strong> 和 <strong>eventbus</strong> 两种方式进行数据通信，两种方式的使用场景略有区别。</p><p><strong>(1) vuex</strong><br>适用场景：一个组件的特定行为改变了另一个平行组件的数据状态。如当点击一个 <strong>Table</strong> 组件列表中某一行的编辑按钮，此时的 <strong>Dialog</strong> 弹窗将展示该行的数据，方法如下：</p><p><em>Table.vue:</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  rowClick () &#123;    </span><br><span class="line">     <span class="keyword">let</span> dialogdata = &#123;&#125;;</span><br><span class="line">     dialogdata[dialogid] = &#123;</span><br><span class="line">       selection: <span class="keyword">this</span>.selection,</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.$store.commit(<span class="string">'SET_DIALOG_DATA'</span>, &#123;</span><br><span class="line">       dialogdata: dialogdata</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Dialog.vue:</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  extraData () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.dialogdata[<span class="keyword">this</span>.pdata.modeid];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>(2) eventbus</strong><br>适用场景：一个组件的特定行为触发另一个平行组件的事件响应。如当点击一个 <strong>Dialog</strong> 弹窗组件的“确认删除”按钮，此时的 <strong>Table</strong> 组件将发起一个删除数据的 <strong>Ajax</strong> 请求，方法如下：</p><p><em>eventbus.js:</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  getBus () &#123;</span><br><span class="line">   <span class="keyword">return</span> bus</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Dialog.vue:</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  buttonClick () &#123;</span><br><span class="line">   eventbus.getBus().$emit(<span class="string">`<span class="subst">$&#123;tmodeid&#125;</span>_event`</span>, &#123;</span><br><span class="line">       action: <span class="string">'delrow'</span>,</span><br><span class="line">       event: &#123;&#125;</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Table.vue:</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  eventbus.getBus().$on(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.pdata.modeid&#125;</span>_event`</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(data.action == <span class="string">'delrow'</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.ajax(data);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>如今 <strong>kube lego</strong> 已经内置了包含基础类、复合类、容器类、表单类、表格类、图表类和原生类等在内的20多个常用组件，可以满足一般管理系统需求开发，但仍然可能不适用于一些特殊的需求，对于这种情况，可以自己扩展一个组件并补充到组件库中，而另一种方法是把这类定制化的组件需求抽象成一个组件。</p><p>在 <strong>kube lego</strong> 里面这个抽象出来的组件叫 <strong>ENative</strong>，可以允许用户自定义 <strong>html</strong> 和 <strong>事件</strong>，实现方法也相当简单，这里主要依赖了 <strong>vue</strong> 的 <strong>v-html</strong> 属性：</p><p><em>ENative:</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">     &lt;div style=<span class="string">"display: none;"</span>&gt;&#123;&#123;extra&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">     &lt;span v-html="html"&gt;&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> common <span class="keyword">from</span> <span class="string">'@/helper/common'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">'data'</span>],</span><br><span class="line">  data: &#123;</span><br><span class="line">   html: <span class="keyword">this</span>.data.html</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">     <span class="keyword">this</span>.$nextTick().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.data.bind()</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated () &#123; <span class="comment">// extra数据变化时更新</span></span><br><span class="line">     <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.html = <span class="keyword">this</span>.data.html;</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>如此一来，可以在配置表中通过下面这种方式使用一个自定义的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;                            </span><br><span class="line">  <span class="string">"mode"</span>: <span class="string">"ENative"</span>,</span><br><span class="line">  <span class="string">"html"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> htm = <span class="string">`</span></span><br><span class="line"><span class="string">       &lt;button id="testBtn"&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">     `</span></span><br><span class="line">     <span class="keyword">return</span> htm;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"bind"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'#testBtn'</span>, () =&gt; &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'biubiu..'</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>目前团队已通过 <strong>kube</strong> 完成多个管理系统开发，下面截取几张通过配置实现的效果图：</p><p><strong>图表统计:</strong></p><p><img src="/img/posts/kube/1530945168_13.png" alt="图表统计"></p><p><strong>数据筛选:</strong></p><p><img src="/img/posts/kube/1530945454_58.png" alt="数据筛选"></p><p><strong>组件嵌套:</strong></p><p><img src="/img/posts/kube/1530945319_47.png" alt="组件嵌套"><br>更多配置案例请见：<a href="http://kg.qq.com/kubedoc" target="_blank" rel="noopener">kube lego文档</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;接触过管理系统研发的同学都知道，此类需求其实相差无几，如何在这方面减少重复劳动，提高工作效率，无论是对自己还是团队都是一件有益的事情
      
    
    </summary>
    
      <category term="前端" scheme="https://boxizen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="组件化 管理系统 配置化 vue" scheme="https://boxizen.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E9%85%8D%E7%BD%AE%E5%8C%96-vue/"/>
    
  </entry>
  
  <entry>
    <title>所见即所得，可视化爬虫实践</title>
    <link href="https://boxizen.github.io/2017/12/07/spider/"/>
    <id>https://boxizen.github.io/2017/12/07/spider/</id>
    <published>2017-12-06T16:00:00.000Z</published>
    <updated>2018-07-07T06:59:13.161Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>前段时间工作上有个需求要爬取东南亚各个国家热门音乐站点的榜单内容，并与K歌内的伴奏素材进行匹配与补充，以此优化用户素材的投放效果。由于音乐站点数量很多，需要分配多个人力执行爬取工作，造成了资源浪费。后在leader的建议下，思考是否能够以一种可配置的方式进行数据爬取，减少一些重复劳动和人力消耗。基于上述原因本人开展了在这项工作上的一些实践。</p></blockquote><p><img src="/img/posts/spider/1512641660_16_w1368_h538.jpeg" alt="可视化爬虫"></p><h3 id="业界产品"><a href="#业界产品" class="headerlink" title="业界产品"></a>业界产品</h3><p>在跟leader沟通过后，首先在百度和知乎搜了搜看看业界是否已经有了这样的方案或产品，搜索结果发现国内被提及最多的是一个叫 <strong>八爪鱼</strong> 和另一个叫 <strong>集搜客</strong> 的平台，八爪鱼看了一下要收费才能使用，遂放弃。而当打开集搜客的官网，有种牛皮藓广告的既视感，顿时也没有欲望继续操作。不过他们的实现原理还是可以了解一下的，经过粗略地观察，发现需要使用人员手写 <strong>正则</strong> 或 <strong>xpath</strong> 的方式制定爬取规则，有一定的使用门槛，并不是我想要的。</p><p>基于 <strong>可视化</strong> 和 <strong>易用性</strong> 两个主要的目的，又Google了一番，结果找到了一款基于 <strong>scrapy</strong> 实现的可视化爬虫工具 <strong>Portia</strong>，正是预期中样子。</p><p><img src="/img/posts/spider/1512641116_96_w1439_h714.jpeg" alt="可视化爬虫"></p><h3 id="可视化操作"><a href="#可视化操作" class="headerlink" title="可视化操作"></a>可视化操作</h3><p>为了后续的定制化和扩展工作可以更方便易行，本人借鉴 <strong>Portia</strong> 实现一套基于 <strong>Node.js</strong> 的所见即所得爬虫系统。</p><p>开展这项工作第一步是给用户提供可视化的操作，手动点击选择想要爬取的元素。这里的实现方式是通过 <strong>iframe</strong> 加载需要爬取的链接，利用 <strong>javascript</strong> 监听 <strong>iframe</strong> 中的 <strong>mouseover</strong> 与 <strong>mouseout</strong> 等事件，以此实现元素审查监听( <strong>xpath</strong> 和内容)，为此简单写了一个js库 - <strong>inspector.js</strong>，效果如下图：</p><p><img src="/img/posts/spider/1512641248_81_w1304_h928.gif" alt="可视化爬虫"></p><p>但这里有个问题是，由于浏览器同源策略的影响，对于 <strong>iframe</strong> 加载不同域网页的情况而言，实际上父页面 <strong>js</strong> 不能操作 <strong>iframe</strong> 中的页面元素，会出现下图中所示的错误，这里就需要考虑把加载的网页转换为同域下的页面。</p><p><img src="/img/posts/spider/1512641273_59_w1598_h138.jpeg" alt="可视化爬虫"></p><p>看了 <strong>Portia</strong> 的做法，它把加载网页代理到自己的服务器上访问，网页中所有资源引用也全部挂载到自己的域下，猜想是使用类似 <strong>nginx</strong> 代理静态资源的方式实现。有了这个思路后，我也采取了类似的方法，利用服务器代理访问链接，这里本人在 <strong>node</strong> 端使用 <strong>PhantomJS</strong> 加载访问链接，再在加载完毕后直接返回页面到浏览器端。</p><div class="tip"><br>为了防止访问站点本身js造成页面阻塞的情况，在返回页面前已将script标签全部移除，同时为确保页面本身的一些行为不会对元素审查过程中造成影响，还需要在iframe中加入sandbox属性:<br></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"xFrame"</span> </span><br><span class="line">  sandbox=<span class="string">"allow-same-origin allow-scripts"</span> </span><br><span class="line">  onload=<span class="string">"xFrameLoad()"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/iframe&gt;</span></span><br></pre></td></tr></table></figure><h3 id="信息爬取"><a href="#信息爬取" class="headerlink" title="信息爬取"></a>信息爬取</h3><p>经过上面用户的一系列可视化操作流程后，已经可以获取得到用户配置的爬取字段信息（字段类型、选择器和其他信息），保存至后台后，我们就可以根据站点入口、字段的类型和对应的选择器获取得到想要的数据。</p><p>对于直出的页面，可以简单地通过 <em>request(url,[callback])</em> 的方式输出页面数据，再从里面提取目标数据。但这种方式对js生成的页面并不起作用。所以后台还是使用了headless浏览器 - PhantomJS统一加载入口页面，并在返回的html中通过cheerio执行数据的筛选和提取，核心代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = <span class="keyword">await</span> phantom.create();</span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> instance.createPage();</span><br><span class="line"><span class="keyword">const</span> status = <span class="keyword">await</span> page.open(url);</span><br><span class="line"><span class="keyword">const</span> html = <span class="keyword">await</span> page.property(<span class="string">'content'</span>);</span><br><span class="line"><span class="keyword">let</span> $ = cheerio.load(html);</span><br></pre></td></tr></table></figure><div class="tip"><br>有些站点页面的图片资源会在拖动滚动条到可视区域才会加载，这就需要在phantom中模拟滚动条拖动的行为，否则不能正常获取得到想要的图片资源：<br></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.property(<span class="string">'scrollPosition'</span>, &#123;</span><br><span class="line">  top: <span class="number">10000</span>,</span><br><span class="line">  left: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><iframe id="iframe" src="//player.bilibili.com/player.html?aid=25934006&cid=44379374&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><p>PS: 家里网速有点慢，loading时间比较长</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;前段时间工作上有个需求要爬取东南亚各个国家热门音乐站点的榜单内容，并与K歌内的伴奏素材进行匹配与补充，以此优化用户素材的投放效果。由
      
    
    </summary>
    
      <category term="自动化" scheme="https://boxizen.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="爬虫" scheme="https://boxizen.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Vue 浅析与实践</title>
    <link href="https://boxizen.github.io/2017/08/22/vue_erp/"/>
    <id>https://boxizen.github.io/2017/08/22/vue_erp/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2018-07-02T14:17:57.036Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><img src="/img/posts/vue/1502722589_86_w1496_h422.png" alt="vue 2.0"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>众所周知，如今的前端框架/解决方案数不胜数，从最初的Backbone，到Angular和Meteor等，这当中有很多都为前端的工程化管理和建设提供了一整套解决方案，是一种“大”框架，但这样的框架往往具备一定的排它性，使得开发的自由和灵活度受到限制。</p><p>与此不同的是，Vue对自己的定位是一个渐进式的JavaScript框架，它最核心的部分是只是为了解决视图层方面的问题，提供<strong>声明式渲染</strong>和<strong>组件化</strong>管理模式。同时对于路由管理、状态管理和构建工作方面又有自己的解决方案，开发者可以自由地选择或者组合，从而能够更加灵活自如地进行项目开发。</p><h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><p><del>手动改变DOM操作是件损耗性能的事情，</del>几乎所有MVX框架都遵循一个原则：视图的状态应该由数据描述，并且通过数据驱动变化。</p><p><img src="/img/posts/vue/1503133912_12_w2016_h642.png" alt="双向数据绑定"></p><p>Vue采用发布者-订阅者模式实现双向数据绑定，首先Vue将会获取到需要监听的对象的所有属性，通过 <strong>Object.defineProperty</strong> 方法完成对象属性的劫持，将其转化为getter和setter，当属性被访问或修改时，立即将变化通知给订阅者，并由订阅者完成相应的逻辑操作，主要流程下图所示。</p><p><img src="/img/posts/vue/1503216087_83_w2126_h1182.jpeg" alt="响应式原理"></p><p>整个过程中主要涉及了 Observer、Dep 和 Watcher三个类，相关源码(已精简)如下：</p><p><strong>Observer:</strong></p><p>主要处理属性监听逻辑，将监听属性转化为get/set属性，当属性被访问时，调用dep.depend() 方法，而属性被修改时，则调用了dep.notify()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 监听属性的get和set方法</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">   val = newVal</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dep:</strong></p><p>担任发布者的角色，维护订阅者列表，负责订阅者的添加和通知工作，上面所提到的depend()和notify()方法在这里实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  id: number;</span><br><span class="line">  <span class="comment">// 订阅者列表</span></span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 属性被访问时调用该方法，</span></span><br><span class="line"> <span class="comment">// 通知依赖的目标（即订阅者）添加该依赖，</span></span><br><span class="line">  <span class="comment">// 同时将其加入订阅者列表中</span></span><br><span class="line"> <span class="comment">// (调用addSub()方法)</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当监听到依赖的属性发生改变时，</span></span><br><span class="line"> <span class="comment">// 通知订阅者执行状态更新操作</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Watcher:</strong></p><p>担任订阅者角色，即上述代码中的 Dep.target，可以订阅多个Dep，在每次收到发布者消息通知时触发update()方法执行更新逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: ISet;</span><br><span class="line">  newDepIds: ISet;  </span><br><span class="line">  <span class="comment">// 为该指令添加依赖（发布者）</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新视图逻辑，依赖的属性值发生改变时触发</span></span><br><span class="line">  update () &#123;</span><br><span class="line"> <span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>过去为了实现父子组件或者平行组件的数据通信，常见的做法是直接或间接地使用 <strong>props</strong> 属性和 <strong>emit()</strong> 方法来实现，这样的做法耦合度强，且难以应付复杂场景下的状态管理。</p><p><strong>Vuex</strong> 的出现可以很好地规避此类问题，它是一种Vue应用的专用状态管理模式，负责集中式地存储和管理整个Vue应用程序的组件状态，实现更好的状态共享。Vuex将组件状态的存储和管理放在了 <strong>Store</strong> 里面，并为其提供了4种特性，分别是 <strong>state</strong>、<strong>actions</strong>、<strong>mutations</strong> 和 <strong>getters</strong>：</p><ul><li><strong>state</strong>，作为驱动应用的数据源，保存了组件的各种状态；</li><li><strong>mutations</strong>，类似于事件，是改变 state 的唯一入口，且里面的操作必须是同步的；</li><li><strong>actions</strong>，类似于 mutations，里面可以进行一些如 ajax 请求等异步的逻辑操作，但如果想对 state 的状态进行修改，必须通过 mutaions 完成；</li><li><strong>getters</strong>，可以对 state 进行某些处理动作，并对处理后的结果提供访问接口。</li></ul><p><img src="/img/posts/vue/1503241390_97_w1894_h968.jpeg" alt="vuex状态管理"></p><p><strong>Vuex</strong>状态管理流程如上图所示，主要分为如下四个步骤：</p><ul><li>视图层中的 <strong>Components</strong> 通过 <strong>this.$store.xxx</strong> 或 <strong>getters</strong> 方法从 <strong>state</strong> 中获取数据并渲染；</li><li>用户在 <strong>Components</strong> 中执行某些动作（如点击按钮fetch数据）时，通过调用 <strong>dispatch()</strong> 方法将执行动作的指令发送到 <strong>Actions</strong> 中对应的方法；</li><li><strong>Actions</strong> 解析请求指令，完成相应的逻辑（如ajax数据请求），并在最后(ajax请求结束后)通过 <strong>commit()</strong> 方法通知 <strong>mutations</strong> 对 <strong>state</strong> 状态进行修改；</li><li><strong>Mutations</strong> 收到 <strong>commit</strong> 请求后，对 <strong>state</strong> 进行赋值操作，以完成数据的修改。</li></ul><p><img src="/img/posts/vue/1503286605_12_w1098_h720.png" alt="vue devtools"></p><p>对于开发过程中 Vuex 状态的追踪，可以通过 Vue Devtools 的 “Vuex” 一栏进行查看，如上图所示，安装方法可以自行搜索。</p><h1 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h1><p><img src="/img/posts/vue/1503302982_86_w1320_h252.png" alt="K歌erp"></p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>全民K歌初期在试水麦克风售卖活动中取得了良好的市场反馈，为继续推动周边实体的售卖，现在期望搭建一个属于自己的售卖平台。整个需求分为H5和PC两部分，其中H5为用户购买实体周边的入口，PC则是对用户的订单数据进行管理。本项目为需求中的PC部分，共由订单数据概览、待审核、待发货、已发货和退换货五页组成。</p><p><img src="/img/posts/vue/1503305805_18_w1200_h800.jpg" alt="项目页面"></p><p>页面具体介绍如下：</p><ul><li><strong>概览页</strong>，包含了整个平台上的交易数据，货品的实时库存以及当前用户的待办事项；</li><li><strong>待审核</strong>，显示最新的订单数据，用户可以在该页中执行订单审核动作；</li><li><strong>待发货</strong>，已经通过审核的订单将会移动至该页，该页为管理员提供了物流信息导入和已经确认发货的动作；</li><li><strong>已发货</strong>，显示已经发货的订单列表，用户可以对发货的地址进行修改，同时也可以执行申请退款的操作；</li><li><strong>退换货</strong>，包含了“待处理“、“”已通过“和“已拒绝”的tab页。其中待处理tab显示了前端发起退货或erp上执行“申请退款“的订单列表，而用户在该列表中执行的动作(允许/拒绝退款)将会使数据移至“”已通过“或“已拒绝”的列表中。</li></ul><p>此外，对于所有的列表页，需要提供批量操作，如批量审核、发货退款和物流信息导入等，并提供分页操作。同时登陆需要通过K歌扫码完成，所有的CGI调用需要在K歌的登陆态下进行。</p><h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><p>项目的构建使用 <code>vue-cli</code> 完成，具体操作流程如下：</p><p><img src="/img/posts/vue/1503301649_26_w877_h484.png" alt="vue-cli构建项目"></p><p>由于公司网络原因，在执行 <strong>vue-init webpack [project-name]</strong> 时会出现无法下载模板库的错误，详情请见<a href="http://km.oa.com/q/view/152812" target="_blank" rel="noopener">此处</a>，解决办法可以是通过设置如图中所示的 npm 代理，或者是直接下载 vue 模板中的<a href="https://github.com/vuejs-templates/webpack/tree/master/template" target="_blank" rel="noopener">wepack库</a>并在本地运行完成。</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><p><img src="/img/posts/vue/1503327316_89_w1300_h231.png" alt="开发实践"></p><p><strong>(1) 目录规划</strong></p><p>本文针对 <code>vue-cli</code> 构建出的项目进行结构上的调整，最终得出如下所示的目录结构：</p><p><img src="/img/posts/vue/1503317713_33_w1530_h1146.png" alt="项目目录结构"></p><p>如上图，client目录为客户端的主要开发目录，主要包含了程序入口文件 <strong>app.js</strong>、客户端路由文件 <strong>router</strong>、客户端视图曾<strong>view</strong>、组件模块<strong>components</strong>和应用状态管理层(即Vuex)<strong>Store</strong>。</p><p><strong>(2) Vuex规范</strong></p><p>前面已经提到，订单相关的页面共有四页，对应着待审核、待发货、已发货和退换货四种状态，由于每种状态的相关操作逻辑不同，在开发过程中将Store中的order模块划分为review、ship、completed和refund四个子模块。下面代码展示了一个简化的review子模块的代码，其他模块的代码与之类似，都包含了 <strong>state</strong>、<strong>mutations</strong>、<strong>getters</strong>和<strong>actions</strong>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/modules/order/review/index.js</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">     re_order_data: &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">     [types.GET_RE_ORDER_LIST] (state, data) &#123;</span><br><span class="line">       state.re_order_data = data</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> getters = &#123;</span><br><span class="line">     re_order_list: <span class="function"><span class="params">state</span> =&gt;</span> state.re_order_list</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> actions = &#123;</span><br><span class="line">     getReOrderList (&#123;commit , state, rootState&#125;, params) &#123;</span><br><span class="line">       common.ajax(&#123;</span><br><span class="line">         url: orderList,</span><br><span class="line">         data:&#123;</span><br><span class="line">           type: <span class="number">5</span>,</span><br><span class="line">           filter_by: STATUS_HAVE_PAY</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;).always(<span class="function"><span class="params">res</span> =&gt;</span> &#123;      </span><br><span class="line">         commit(<span class="string">'GET_RE_ORDER_LIST'</span>, res.data)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">     state,</span><br><span class="line">     mutations,</span><br><span class="line">     getters,</span><br><span class="line">     actions</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此时你也许注意到，Store被划分成多个模块，而每个模块里面可能又会有更细粒度的划分。在实际的运行过程中，需要对这些模块进行整合，这里需要用到Vuex提供的modules属性，相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'./modules/app'</span></span><br><span class="line"><span class="keyword">import</span> menu <span class="keyword">from</span> <span class="string">'./modules/menu'</span></span><br><span class="line"><span class="keyword">import</span> order <span class="keyword">from</span> <span class="string">'./modules/order'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    app,</span><br><span class="line">    menu,</span><br><span class="line">    ...order</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>(3) 组件调用</strong></p><p>组件对Vuex中state状态的调用逻辑通常是放在 <strong>data</strong> 或 <strong>computed</strong> 属性中，但需要注意的是，如果期望得到的是响应式的数据，则必须将调用逻辑放在计算属性 <strong>computed</strong> 中，这样当每次state状态发生变化时，<strong>computed</strong> 属性中的数据都会被重新计算，同时重新触发更新视图。此外组件也可以直接调用Vuex中的mutations和actions事件，这通常放在<strong>methods</strong>属性中进行。</p><p><strong>(4) 其他</strong></p><p><strong>路由处理</strong>，对于一个单页应用，自然少不了路由处理，项目的路由使用官方的vue-router处理，使用<code>router.beforeEach()</code>方法在每次路由跳转前进行拦截，判断用户是否登录，如没有登录则跳转至登录页。</p><p><strong>网络请求</strong>，Vue 2.0开始不再维护 vue-resourse，转而推荐 <strong>axios</strong> 作为标准的网络请求库，但是由于 <strong>axios</strong> 不支持 <strong>jsonp</strong> 跨域方式，遂放弃，在项目中使用了团队的 ajax 模块。</p><p><strong>延迟加载</strong>，项目使用了webpack作为打包构建工具，打包结束后默认情况下会产生两个js文件：app.js和vendor.js，而项目在一开始就已经加载了这两个js文件，如果要想实现路由的延迟加载，需要将路由请求的组件定位为<strong>异步组件</strong>，并结合webpack的代码分割特性实现，方法是通过 <code>require.ensure</code> 的方式引入组件。</p><h1 id="最后说句"><a href="#最后说句" class="headerlink" title="最后说句"></a>最后说句</h1><p>本篇文章前半部分对 vue2.0 进行了浅析：分析关于响应式方面的源码，了解具体的实现原理与模式，并对Vuex 数据管理做了知识梳理与流程说明。后半部分则是在项目中应用了 Vue 的技术栈，并对实践过程中的代码细节和关键点做了总结。</p><p>在整个开发过程中，能够较为深刻地体会到vue对于代码编写的舒适性(来自于组件化的管理方式)以及vuex对于代码组织方面的优雅。另外由于时间上的关系（实际上是因为懒）， 还没有仔细了解关于Vue 渲染方面的原理，希望可以找个时间在后续补上这部分内容。</p><p>谢谢阅读，欢迎指正 (=^_^=)</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zhihu.com/question/51907207" target="_blank" rel="noopener">Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？</a></li><li><a href="http://www.infoq.com/cn/articles/vue-2-progressive-front-end-solution/" target="_blank" rel="noopener">Vue 2.0——渐进式前端解决方案</a></li><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入Vue 2,0响应式原理</a></li><li><a href="https://github.com/vuejs/vue/tree/dev/src/core/observer" target="_blank" rel="noopener">Vue observer源码</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="前端" scheme="https://boxizen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="VueJS" scheme="https://boxizen.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>Electron 构建跨平台桌面应用</title>
    <link href="https://boxizen.github.io/2016/09/11/electron/"/>
    <id>https://boxizen.github.io/2016/09/11/electron/</id>
    <published>2016-09-10T16:00:00.000Z</published>
    <updated>2018-06-30T14:53:52.675Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><p><img src="/img/posts/electron/electron.jpeg" alt="electron apps"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Electron 是一款可以通过 Web前端技术 构建跨平台桌面应用的框架。其原名为 Atom Shell， 是 Github 社区原本为 Atom 编辑器设计的一个跨平台应用外壳，它将 Chromium 和 Node.js 的事件循环整合在一起，并提供了一些与原生系统交互的 API。</p><p>简单地说，通过 Electron，我们可以使用自己所熟悉的前端技术轻松构建出一款能运行在Windows, Linux 和 Mac 上的桌面级应用程序。</p><p>现阶段已有许多优秀的桌面应用都是基于 Electron 开发，其中如 Atom 编辑器，VS Code 和 Postman 等等都是我们所熟知的，下面列出这当中的部分应用，是不是看到了许多熟悉的图标呢？</p><p><img src="/img/posts/electron/electron_apps.jpeg" alt="electron apps"></p><h1 id="Electron-和-NW-js"><a href="#Electron-和-NW-js" class="headerlink" title="Electron 和 NW.js"></a>Electron 和 NW.js</h1><p>其实使用 Web前端技术 构建桌面应用早已不是什么新鲜事，在业界里诸如 NW.js，Brackets-Shell 和 HEX 框架也可以做同样的事情，而在 Electron 出现之前，NW.js 的发展势头最为猛烈。</p><h2 id="从-node-webkit-到-Atom-Shell"><a href="#从-node-webkit-到-Atom-Shell" class="headerlink" title="从 node-webkit 到 Atom Shell"></a>从 node-webkit 到 Atom Shell</h2><p>相信前端开发者对 NW.js 并不陌生，它的前身又叫 node-webkit，同样是一种跨平台桌面应用的开发框架。而说起 NW.js 和 Electron 之间的一段渊源可能却鲜有人知道：</p><p>node-webkit 项目最先由 Intel 公司的 <a href="https://github.com/rogerwang" target="_blank" rel="noopener">王文睿</a> 发起，由于公司投入的资源较少，前期的主要开发和维护工作主要由实习生 <a href="https://github.com/zcbenz" target="_blank" rel="noopener">赵成</a> 完成。据该实习生后来的描述，在 node-webkit 项目引起越来越多人的关注与使用后，自己失去了对该项目的完全自主权，恰逢 Github 此时在寻找一种利用 HTML 和 Node.js 开发桌面应用的方式，这成为了他转战 Github，投入到 Atom Shell 开发的重要原因。</p><p>下图为 NW.js 前期的提交贡献记录(左边是赵成，右边为王文睿)：</p><p><img src="/img/posts/electron/nw_commit.png" alt="node-webkit commits"></p><h2 id="主要差异"><a href="#主要差异" class="headerlink" title="主要差异"></a>主要差异</h2><p>针对与 NW.js 的主要差异，Electron 官方给出了如下四个方面：</p><p><em>1. 应用的入口</em></p><p>与 NW.js 不同的是，Electron 采用一个 JavaScript 脚本作为入口程序(NW.js 使用 HTML 文件作为入口)，并在该脚本中创建和维护窗体的生命周期，这种做法更加贴近传统 Node.js 的写法，与 Chrome Packaged App 的做法一致，为程序开发能够带来一定灵活性。</p><p><em>构建系统</em></p><p>为避免构建整个 Chromium 带来的复杂度，Electron 通过一个独立的共享库 libchromiumcontent 来访问 Chromium 的 Content API。</p><p><em>Node集成</em></p><p>在 NW.js 中，Node 的集成需要在 Chromium 中打补丁来实现，而Electron 则通过各个平台的消息循环与 libuv 的循环集成，避免了直接在 Chromium 上做改动。</p><p><em>多上下文</em></p><p>NW.js 里面包含了 node context 和 web context，而在 Electron 中仅有一个 context，这得益于 Node.js 的多上下文特性。</p><p>当然，Electron 优于 NW.js 的地方不仅仅只有上面所描述的几点，更丰富的文档资料，更活跃的社区，更及时的更新以及更多成熟应用的诞生使 electron 得到了越来越多人的推崇与贡献。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="案例运行"><a href="#案例运行" class="headerlink" title="案例运行"></a>案例运行</h2><p>使用下面三步即可构建最简单的 Hello World 桌面程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 克隆官方的例子</span><br><span class="line">$ git clone https:<span class="comment">//github.com/electron/electron-quick-start</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 进入项目目录</span><br><span class="line">$ cd electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 安装项目依赖后执行该程序</span><br><span class="line">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>运行效果如下:</p><p><img src="/img/posts/electron/hello_world.jpeg" alt="hello world"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>察看目录结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .gitignore</span><br><span class="line">├── index.html</span><br><span class="line">├── LICENSE.md</span><br><span class="line">├── main.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── renderer.js</span><br></pre></td></tr></table></figure><p>主要分为三个部分:</p><ul><li>package.json: 定义了项目的依赖以及程序的主入口文件 main.js。</li><li>main.js: 负责创建应用窗口，并赋予其与当前操作系统的原生GUI交互的功能。</li><li>index.html: 定义了页面的渲染内容，即 “Hello World” 字符串。</li></ul><p>Electron 程序启动时，会产生两条进程，分别是主进程和渲染进程，main.js 脚本执行的环境就是主进程，负责管理和维护着渲染进程的生命周期，拥有绝大部分 node模块 的调用能力；而在 main.js 中创建的每一个窗体则对应着一个渲染进程，它们之间相互独立，且都具备部分 Node模块 的功能。</p><p>主进程与渲染进程的关系如下图所示，它们之间通过 IPC 模块进行消息交互，关于 IPC 模块的使用，下面会提到。</p><p><img src="/img/posts/electron/atom-shell-structure.png" alt="structure"></p><h1 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h1><p>这个部分将介绍 Electron 里面常用到的几个功能模块。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>上面提到，Electron 中包含了主进程和渲染进程，事实上主进程就是一个后台进程，掌控着渲染进程的创建与销毁动作，且官方提供的绝大部分模块也只能在该进程中调用。</p><p>主进程与渲染进程之间的通信通过 IPC(进程间通信)模块完成，IPC模块可划分为 ipcMain 和 ipcRenderer 两个部分，其中 ipcMain 对应 主进程中的 IPC模块，而 ipcRenderer 则是在渲染进程中使用，下面直接看个例子:</p><p>main.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 ipcMain 模块</span></span><br><span class="line"><span class="keyword">const</span> ipcMain = <span class="built_in">require</span>(<span class="string">'electron'</span>).ipcMain;</span><br><span class="line"><span class="comment">// 监听 ‘blabla’ 通道，收到消息后输出，并向 'blibli' 通道发送消息</span></span><br><span class="line">ipcMain.on(<span class="string">'blabla'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">  event.sender.send(<span class="string">'blibli'</span>, <span class="string">'hello client!'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 ipcRenderer 模块</span></span><br><span class="line"><span class="keyword">const</span> ipcRenderer = <span class="built_in">require</span>(<span class="string">'electron'</span>).ipcRenderer;  </span><br><span class="line"><span class="comment">// 向 'blabla' 通道发送消息</span></span><br><span class="line">ipcRenderer.send(<span class="string">'blabla'</span>, <span class="string">'hello server!'</span>);</span><br><span class="line"><span class="comment">// 监听 ‘blibli’ 通道, 收到消息后输出</span></span><br><span class="line">ipcRenderer.on(<span class="string">'blibli'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event,arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出效果正如你所期望那样:</p><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello server!</span><br></pre></td></tr></table></figure><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello client!</span><br></pre></td></tr></table></figure><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>上面提到了大部分模块只能在主进程中调用，为了突破这种限制，Electron 官方还提供了 remote 模块以简化进程间的通讯。</p><p>通过 remote 模块，渲染进程可以方便地引用主进程中的模块和全局变量等。</p><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global.person = &#123;</span><br><span class="line">  name: <span class="string">'boxizen'</span>,</span><br><span class="line">  sex : <span class="string">'male'</span>,</span><br><span class="line">  age : <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用 remote 模块</span></span><br><span class="line"><span class="keyword">const</span> remote = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote;</span><br><span class="line"><span class="comment">// 输出 main.js 中定义的 person 全局对象的 age 属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(remote.getGlobal(<span class="string">'person'</span>).age);</span><br></pre></td></tr></table></figure><p>输出效果(index.html):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><h2 id="lt-webview"><a href="#lt-webview" class="headerlink" title="&lt;webview>"></a>&lt;webview></h2><p>&lt;webview> 是个比较有趣的标签，可以将线上的页面嵌入进 Electron app 中，与 iframe 不同的是，webview 和应用运行的是不同的进程，不拥有渲染进程的权限。</p><p>下面将演示如何将微信网页版嵌入进 Electron 应用里，只需要简单的两步：</p><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;webview autosize=<span class="string">"on"</span> src=<span class="string">"https://wx.qq.com/"</span> style=<span class="string">"display:inline-flex; width:1000px; height:764px"</span>&gt;&lt;/webview&gt;</span><br></pre></td></tr></table></figure><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">1000</span>, <span class="attr">height</span>: <span class="number">764</span>, <span class="attr">resizable</span>: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/img/posts/electron/wechat.jpg" alt="wechat"></p><p>这样一个PC版的微信就大功告成了，实际上就是把利用 webview 标签加载微信网页版的在线地址，再在main.js中调整窗体大小以适配网页版的微信，是不是很简单呢。</p><p>webview 对象中包含 <strong>insertCSS()</strong> 和 <strong>executeJavaScript()</strong> 两个方法，表示可以插入样式代码和执行 js 脚本，这样我们就可以对加载页面中的样式及交互逻辑进行修改。默认的 webview 没有 node 功能，而如果设置了 nodeintegration 属性，它将整合node，拥有可以使用系统底层的资源。</p><p>此外 webview 中的 <strong>preload</strong> 属性允许在页面的脚本执行前预加载一个指定的脚本，下面我们利用该属性和 <strong>executeJavaScript()</strong> 方法实现 electron 版微信的未读消息角标展示。</p><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这里使用 preload 属性预加载了 badge.js 脚本 --&gt;</span><br><span class="line">&lt;webview id=<span class="string">"foo"</span> autosize=<span class="string">"on"</span> preload=<span class="string">"badge.js"</span> src=<span class="string">"https://wx.qq.com/"</span> style=<span class="string">"display:inline-flex; width:1000px; height:764px"</span>&gt;&lt;/webview&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> webview = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>);      </span><br><span class="line">  webview.addEventListener(<span class="string">'dom-ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;             </span><br><span class="line">  webview.executeJavaScript(<span class="string">'badge.get()'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>badge.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 IPC 模块</span></span><br><span class="line"><span class="keyword">const</span> ipcRenderer = <span class="built_in">require</span>(<span class="string">'electron'</span>).ipcRenderer;</span><br><span class="line"></span><br><span class="line">badge = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// 监听微信左侧面板节点变化</span></span><br><span class="line">    $(<span class="string">".panel"</span>).bind(<span class="string">'DOMSubtreeModified'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      </span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">0</span>;   </span><br><span class="line">      <span class="comment">// 累加所有未读消息   </span></span><br><span class="line">      $(<span class="string">".icon.web_wechat_reddot_middle"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        count += <span class="built_in">parseInt</span>(<span class="keyword">this</span>.textContent);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 通过 IPC 发送给主进程</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipcRenderer.send(<span class="string">'badge-changed'</span>, count.toString());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ipcRenderer.send(<span class="string">'badge-changed'</span>, <span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"><span class="keyword">const</span> ipcMain = electron.ipcMain;</span><br><span class="line"><span class="keyword">const</span> app = electron.app</span><br><span class="line"></span><br><span class="line">exports.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听角标通道消息</span></span><br><span class="line">  ipcMain.on(<span class="string">'badge-changed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, num</span>) </span>&#123;</span><br><span class="line">    app.dock.setBadge(num);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下，可以发现 Electron 的 dock 角标显示的未读消息数(11)跟微信中面板中未读消息数量一致:</p><p><img src="/img/posts/electron/dock.jpg" alt="wechat"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然 Electron 中还有许多实用的模块，如作为桌面中必不可少的 <strong>Menu</strong> 和 <strong>Tray</strong> 模块、拥有调用当前操作系统功能的 <strong>Shell</strong> 模块、NW.js 中不具备的自动更新功能 - <strong>autoUpdater</strong> 模块、自动提交奔溃报告的 <strong>crashReporter</strong> 模块和全局快捷键模块 <strong>global-shortcut</strong> 等等，此处不做过多介绍。</p><h1 id="打包构建"><a href="#打包构建" class="headerlink" title="打包构建"></a>打包构建</h1><p>Electron 打包的方式有很多种，常见的有 electron-builder、electron-packager 和 asar几种，在这里我使用的是 electron-packager 作为应用的打包工具。</p><p>首先还是得先安装 electron-packager:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install electron-packager --save-dev</span><br></pre></td></tr></table></figure><p>然后在 package.json 中编写构建命令，下面生成了分别在 Windows 和 Mac 下的两条构建命令:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"> <span class="string">"start"</span>: <span class="string">"electron ."</span>,</span><br><span class="line"> <span class="string">"build-win"</span>: <span class="string">"electron-packager . doubanFM --platform=win32 --arch=x64 --version=1.2.6 --icon=./fm.ico --overwrite --ignore=node_modules/electron-*"</span>,</span><br><span class="line"> <span class="string">"build-mac"</span>: <span class="string">"electron-packager . doubanFM --platform=darwin --arch=x64 --version=1.2.6 --icon=./fm.icns --overwrite"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行构建命令, done!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build-mac</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;img src=&quot;/img/posts/electron/electron.jpeg&quot; alt=&quot;electron apps&quot;&gt;&lt;/p&gt;&lt;h1 id=&quot;简
      
    
    </summary>
    
      <category term="前端" scheme="https://boxizen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="electron 跨平台" scheme="https://boxizen.github.io/tags/electron-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量JavaScript代码</title>
    <link href="https://boxizen.github.io/2016/04/05/effective_javascript/"/>
    <id>https://boxizen.github.io/2016/04/05/effective_javascript/</id>
    <published>2016-04-04T16:00:00.000Z</published>
    <updated>2018-07-09T12:04:37.868Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>汇总《Effective JavaScript》68个有效方法。</p></blockquote><h2 id="一、JavaScript特性"><a href="#一、JavaScript特性" class="headerlink" title="一、JavaScript特性"></a>一、JavaScript特性</h2><h3 id="第1条-JavaScript版本"><a href="#第1条-JavaScript版本" class="headerlink" title="第1条: JavaScript版本"></a><strong>第1条: JavaScript版本</strong></h3><p>JavaScript在1997年正式成为国际标准(ECMAScript)，至今共经历了多个版本，如1999年定稿的ES3、2009年发布的ES5和2015年确定的ES6等，不同平台上支持的版本有差异，因此确定当前运行环境所支持的ES版本至关重要。</p><p>ES5引入了一种版本控制的考量－严格模式(strict mode)，用于禁止使用一些JavaScript语言中问题较多或易于出错的特性，这种写法向后兼容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行函数代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第2条-JavaScript浮点数"><a href="#第2条-JavaScript浮点数" class="headerlink" title="第2条: JavaScript浮点数"></a><strong>第2条: JavaScript浮点数</strong></h3><p>不同于其他编程语言，JavaScript的数值型数据类型只有一种：双精度浮点数(double－由IEEE754标准制定的64位编码数字，可以表示高达53位精度的整数)，对于浮点数的运算应该时刻保持警惕，它们的运算并不精确，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>; <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>解决办法是尽可能地采用整数值运算，因为整数在表示时不需要摄入。</p><h3 id="第3条-隐式的强制转换"><a href="#第3条-隐式的强制转换" class="headerlink" title="第3条: 隐式的强制转换"></a><strong>第3条: 隐式的强制转换</strong></h3><p>JavaScript对类型错误出奇地/宽容，许多在其他动态类型语言中的表达式被认为是错误的，而在JavaScript中却可以正确地运行。<br>如算术运算符 -、 *、 / 和 ％ 在计算前会尝试将其参数转换为数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为NaN</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isReallyNaN</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x !== x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个对象存在toString()和valueOf()方法时，在执行+运算时默认调用的是valueOf()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'string method'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj: '</span> + obj); <span class="comment">// obj: 0</span></span><br></pre></td></tr></table></figure><p>JavaScript中有7个假值: false、0、－0、””、NaN、null和undefined，其他所有的值均为真值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数忽略任何为假值的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">   x = <span class="number">320</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!y) &#123;</span><br><span class="line">   y = <span class="number">240</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查参数是否为undefined更为严格的方式是使用typeof或者和undefined比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof判断</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">'undefined'</span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和undefined比较</span></span><br><span class="line"><span class="keyword">if</span>(x === <span class="literal">undefined</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="第4条-原始类型优于封装对象"><a href="#第4条-原始类型优于封装对象" class="headerlink" title="第4条: 原始类型优于封装对象"></a><strong>第4条: 原始类型优于封装对象</strong></h3><p>除了对象以外，JavaScript有5个原始值类型：布尔值、数字、字符串、null和undefined。</p><p>当作相等比较时，原始类型的封装对象与其原始值行为不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line">s1 === s2; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">'hello'</span>;</span><br><span class="line">s3 === s4; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>获取和设置原始类型值的属性会隐式地创建封装对象，因此对原始类型设置属性是没有意义的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.someProperty = <span class="number">17</span>;</span><br><span class="line"><span class="string">'hello'</span>.someProperty; <span class="comment">// undefined;</span></span><br></pre></td></tr></table></figure><h3 id="第5条-避免对混合类型使用-运算符"><a href="#第5条-避免对混合类型使用-运算符" class="headerlink" title="第5条: 避免对混合类型使用==运算符"></a><strong>第5条: 避免对混合类型使用==运算符</strong></h3><p>当参数类型不同时，＝＝运算符应用了一套难以理解的隐式强制类型转换规则，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   参数类型<span class="number">1</span>    |  参数类型<span class="number">2</span>   |  强制转换 |</span><br><span class="line">| :-----------: | :-----------:  | :-------: |</span><br><span class="line">| <span class="literal">null</span>| <span class="literal">undefined</span>| 不转换，总是返回<span class="literal">true</span>|</span><br><span class="line">| <span class="literal">null</span>或<span class="literal">undefined</span> | 其他任何非<span class="literal">null</span>或<span class="literal">undefined</span>的类型 | 不转换，总是返回<span class="literal">false</span> |</span><br><span class="line">| 原始类型: string、number或boolean | <span class="built_in">Date</span>对象 | 原始类型转换为数字；<span class="built_in">Date</span>对象转换为原始类型(优先尝试toString，再尝试valueOf) |</span><br><span class="line">| 原始类型: string、number或boolean | 非<span class="built_in">Date</span>对象 | 原始类型转换为数字；将非<span class="built_in">Date</span>对象转换为原始类型(优先尝试valueOf，再尝试toString) |</span><br><span class="line">| 原始类型: string、number或boolean | 原始类型: string、number或boolean | 将原始类型转换为数字 |</span><br></pre></td></tr></table></figure><p>==运算符应用的转换规则难以理解，在比较不同类型的值时，可使用显示强制转换使程序的行为更为清晰。</p><h3 id="第6条-了解分号插入的局限"><a href="#第6条-了解分号插入的局限" class="headerlink" title="第6条: 了解分号插入的局限"></a><strong>第6条: 了解分号插入的局限</strong></h3><p>在以 ( 、 [ 、 + 、 － 、 或 / 字符开头的语句前绝不能省略分号。</p><p>当脚本连接的时候，在脚本之间显示地插入分号。</p><p>在return、throw、break、continue、++或–的参数之前不能换行。</p><h3 id="第7条-视字符串为16位的代码单元序列"><a href="#第7条-视字符串为16位的代码单元序列" class="headerlink" title="第7条: 视字符串为16位的代码单元序列"></a><strong>第7条: 视字符串为16位的代码单元序列</strong></h3><p>略</p><h2 id="二、变量作用域"><a href="#二、变量作用域" class="headerlink" title="二、变量作用域"></a>二、变量作用域</h2><h3 id="第8、9条-尽量少用全局对象，始终声明局部变量"><a href="#第8、9条-尽量少用全局对象，始终声明局部变量" class="headerlink" title="第8、9条: 尽量少用全局对象，始终声明局部变量"></a><strong>第8、9条: 尽量少用全局对象，始终声明局部变量</strong></h3><p>在JavaScript中，定义全局变量会污染共享的公共命名空间，并可能导致意外的命名冲突。全局变量不利于模块化，因为它会导致程序中独立组件间的不必要耦合</p><p>因此应该尽可能避免声明全局变量，转而使用局部变量取代。</p><h3 id="第10条-避免使用with"><a href="#第10条-避免使用with" class="headerlink" title="第10条: 避免使用with"></a><strong>第10条: 避免使用with</strong></h3><p>程序经常需要对单个对象依次调用一系列方法，<strong>with</strong>语句的动机在于方便地避免对对象的重复引用，而这种方便却是以不可靠和低效率为代价的。</p><p>在with语句中使用某变量时，虽然会在with对象的作用域中查找是否存在该变量，如果存在，则使用with对象中的变量，否则会在上一层作用域中查找该变量，这种做法导致了变量容易混淆和查找效率低两种后果。</p><p>因此应该尽可能避免使用with语句，可通过<strong>使用简单的变量名代替重复访问的对象</strong>和<strong>显示绑定局部变量到对象属性上</strong>两种方式取代with语句。</p><p><strong>变量名代替重复访问的对象:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">status</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> w = <span class="keyword">new</span> Widget();</span><br><span class="line">  w.setBackground(<span class="string">'blue'</span>);</span><br><span class="line">  w.setForeground(<span class="string">'white'</span>);</span><br><span class="line">  w.addText(<span class="string">'status:'</span> + info);</span><br><span class="line">  w.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显示绑定局部变量到对象属性上:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min = <span class="built_in">Math</span>.min, round = <span class="built_in">Math</span>.round, sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line">  <span class="keyword">return</span> min(round(x), sqrt(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第11条-熟练使用闭包"><a href="#第11条-熟练使用闭包" class="headerlink" title="第11条: 熟练使用闭包"></a><strong>第11条: 熟练使用闭包</strong></h3><p>闭包是JavaScript中的特性，有如下三个特点：</p><p><strong>1. 允许引用在当前函数外定义的变量:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSandwich</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> magicIngredient = <span class="string">'peanut butter'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> magicIngredient + <span class="string">' and '</span> + filling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make(<span class="string">'jelly'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sandwichMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> magicIngredient = <span class="string">'peanut butter'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> magicIngredient + <span class="string">' and '</span> + filling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = sandwichMaker();</span><br><span class="line">f(<span class="string">'jelly'</span>);</span><br></pre></td></tr></table></figure><p><strong>3. 闭包可以更新外部变量的值:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> val = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  val = newVal;</span><br><span class="line">   &#125;,</span><br><span class="line">   get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">   &#125;,</span><br><span class="line">   type: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = box();</span><br><span class="line">b.type(); <span class="comment">// undefined;</span></span><br><span class="line">b.set(<span class="number">98.6</span>);</span><br><span class="line">b.get(); <span class="comment">// 98.6</span></span><br><span class="line">b.type(); <span class="comment">// 'number'</span></span><br></pre></td></tr></table></figure><h3 id="第12条-理解变量声明提升"><a href="#第12条-理解变量声明提升" class="headerlink" title="第12条: 理解变量声明提升"></a><strong>第12条: 理解变量声明提升</strong></h3><p>在代码块中的变量声明会被隐式地提升到封闭函数的顶部，我们称之为<strong>变量提升</strong>。</p><p>需要注意的是JavaScript没有块级作用域，但其中一个例外是<strong>try-catch</strong>语句:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'var'</span>, result = [];</span><br><span class="line">  result.push(x);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'exception'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(x) &#123;</span><br><span class="line"> x = <span class="string">'catch'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result.push(x);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// ['var', 'var']</span></span><br></pre></td></tr></table></figure><h3 id="第13条-使用立即调用的函数表达式创建局部作用域"><a href="#第13条-使用立即调用的函数表达式创建局部作用域" class="headerlink" title="第13条: 使用立即调用的函数表达式创建局部作用域"></a><strong>第13条: 使用立即调用的函数表达式创建局部作用域</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapElements</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [], i, n;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>, n = a.length; i &lt; n; i++) &#123;</span><br><span class="line"> result[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a[i];</span><br><span class="line"> &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> w = wrapElements([<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">43</span>]);</span><br><span class="line">w[<span class="number">0</span>]; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="第16条-避免使用eval创建局部变量"><a href="#第16条-避免使用eval创建局部变量" class="headerlink" title="第16条: 避免使用eval创建局部变量"></a><strong>第16条: 避免使用eval创建局部变量</strong></h3><p>eval函数容易污染调用者的作用域，如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x) &#123;</span><br><span class="line"> <span class="built_in">eval</span>(<span class="string">'var y = "local";'</span>); <span class="comment">// 动态绑定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">true</span>); <span class="comment">// local</span></span><br><span class="line">test(<span class="literal">false</span>); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><p>保证eval函数不影响外部作用域的一个方法是在一个明确的嵌套作用域中运行它，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">eval</span>(src);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'var y = "local";'</span>); <span class="comment">// global</span></span><br><span class="line">test(<span class="string">'var z = "local";'</span>); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><h3 id="第17条-间接调用eval函数优于直接调用"><a href="#第17条-间接调用eval函数优于直接调用" class="headerlink" title="第17条: 间接调用eval函数优于直接调用"></a><strong>第17条: 间接调用eval函数优于直接调用</strong></h3><h2 id="三、使用函数"><a href="#三、使用函数" class="headerlink" title="三、使用函数"></a>三、使用函数</h2><h3 id="第18条-函数调用、方法调用及构造函数调用区别"><a href="#第18条-函数调用、方法调用及构造函数调用区别" class="headerlink" title="第18条: 函数调用、方法调用及构造函数调用区别"></a><strong>第18条: 函数调用、方法调用及构造函数调用区别</strong></h3><p>有别于其他面向对象编程语言，JavaScript 将函数调用、方法调用以及构造函数调用看作是单个构造对象的三种不同的使用模式。</p><h3 id="第19条-熟练掌握高阶函数"><a href="#第19条-熟练掌握高阶函数" class="headerlink" title="第19条: 熟练掌握高阶函数"></a><strong>第19条: 熟练掌握高阶函数</strong></h3><p>所谓高阶函数，即是使用函数作为<strong>参数</strong>或<strong>返回值</strong>的函数，常常用于数组的方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">"ABC"</span>, <span class="string">"dEf"</span>, <span class="string">"GHI"</span>];</span><br><span class="line"><span class="keyword">var</span> lower = names.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.toLowerCase();</span><br><span class="line">&#125;)</span><br><span class="line">lower; <span class="comment">// ['abc', 'def', 'ghi']</span></span><br></pre></td></tr></table></figure><p>此外，高阶函数还可用于重构并整合一些相同的模式，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alphabet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> aIndex = <span class="string">"a"</span>.charCodeAt(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> alphabet = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    alphabet += <span class="built_in">String</span>.fromCharCode(aIndex + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">digits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> digits = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    digits += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> random = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    random += <span class="built_in">String</span>.fromCharCode(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">26</span>) + aIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数创建了不同的字符串，但是他们都有着共同的逻辑，可以通过编写一个高阶函数提取出共用的部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildString</span>(<span class="params">n, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result += callback(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是上面的三个例子可以简化为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alphabet = buildString(<span class="number">26</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(alIndex + i);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> digits = buildString(<span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> random = buildString(<span class="number">8</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">String</span>.fromCharCode(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">26</span>)+ aIndex);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第20条-使用call调用方法"><a href="#第20条-使用call调用方法" class="headerlink" title="第20条: 使用call调用方法"></a><strong>第20条: 使用call调用方法</strong></h3><p>在很多业务场景下，开发者常常需要自定义对象作为某个函数的调用者，首先想到的方法可能是将该函数作为一个新的属性添加到接受者对象中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.temporary = f;</span><br><span class="line"><span class="keyword">var</span> result = obj.temporary(arg1, arg2, arg3);</span><br><span class="line"><span class="keyword">delete</span> obj.temporay;</span><br></pre></td></tr></table></figure><p>然而这种方法看上去非常别扭而危险，一般而言这种做法是一种不好的实践，可通过 call 解决这样的问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(obj, arg1, arg2, arg3);</span><br></pre></td></tr></table></figure><h3 id="第21条-使用apply调用方法"><a href="#第21条-使用apply调用方法" class="headerlink" title="第21条: 使用apply调用方法"></a><strong>第21条: 使用apply调用方法</strong></h3><p>apply 与 call 类似，区别在于 apply 接收的参数对象为数组对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = getAllScores();</span><br><span class="line">average.apply(<span class="literal">null</span>, scores);</span><br></pre></td></tr></table></figure><h3 id="第22-24条-arguments对象"><a href="#第22-24条-arguments对象" class="headerlink" title="第22-24条: arguments对象"></a><strong>第22-24条: arguments对象</strong></h3><p>隐式的 arguments 对象可实现可变参数的函数，虽然 arguments 看起来像一个数组，但它并不是一个真正的数组，可通过下面的方法将它转化为真正的数组:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="第25-26条-使用bind方法"><a href="#第25-26条-使用bind方法" class="headerlink" title="第25-26条: 使用bind方法"></a><strong>第25-26条: 使用bind方法</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = &#123;</span><br><span class="line">  entries: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.entries.push(s);</span><br><span class="line">  &#125;,</span><br><span class="line">  concat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.entries.join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">buffer.add.bind(buffer); <span class="comment">//绑定buffer对象为函数接受者</span></span><br></pre></td></tr></table></figure><h3 id="第28条-不要信赖函数对象的toString方法"><a href="#第28条-不要信赖函数对象的toString方法" class="headerlink" title="第28条: 不要信赖函数对象的toString方法"></a><strong>第28条: 不要信赖函数对象的toString方法</strong></h3><p>通常情况下，应该避免使用函数对象的 toString 方法。</p><h3 id="第29条-避免使用非标准的栈检查属性"><a href="#第29条-避免使用非标准的栈检查属性" class="headerlink" title="第29条: 避免使用非标准的栈检查属性"></a><strong>第29条: 避免使用非标准的栈检查属性</strong></h3><p>避免使用非标准的 arguments.caller 和 arguments.callee 属性</p><h2 id="四、对象和原型"><a href="#四、对象和原型" class="headerlink" title="四、对象和原型"></a>四、对象和原型</h2><h3 id="第30条-理解prototype、getPrototype和proto之间的不同"><a href="#第30条-理解prototype、getPrototype和proto之间的不同" class="headerlink" title="第30条: 理解prototype、getPrototype和proto之间的不同"></a><strong>第30条: 理解prototype、getPrototype和<strong>proto</strong>之间的不同</strong></h3><ul><li>C.prototype 属性是 new C() 创建的对象的原型。</li><li>Object.getPrototypeOf(obj) 是 ES5 中检索对象原型的标准函数。</li><li>obj.<strong>proto</strong> 是检索对象原型的非标准方法。</li><li>类是由一个构造函数和一个关联的原型组成的一种设计模式。</li></ul><h3 id="第31条-使用getPrototypeOf函数代替proto属性"><a href="#第31条-使用getPrototypeOf函数代替proto属性" class="headerlink" title="第31条: 使用getPrototypeOf函数代替proto属性"></a><strong>第31条: 使用getPrototypeOf函数代替<strong>proto</strong>属性</strong></h3><p>ES5 引入 Object.getPrototypeOf 函数作为获取对象原型的标准 API，而在此之前大量的 JavaScript 引擎使用 <strong>proto</strong> 属性达到相同的目的，但由于该属性并不是完全兼容</p><h3 id="第32条-始终不要修改proto属性"><a href="#第32条-始终不要修改proto属性" class="headerlink" title="第32条: 始终不要修改proto属性"></a><strong>第32条: 始终不要修改<strong>proto</strong>属性</strong></h3><ul><li>始终不要修改对象的 <strong>proto</strong> 属性。</li><li>使用 Object.create 函数给新对象设置自定义的原型</li></ul><h3 id="第34条-在原型中存储方法"><a href="#第34条-在原型中存储方法" class="headerlink" title="第34条: 在原型中存储方法"></a><strong>第34条: 在原型中存储方法</strong></h3><p>将方法存储在实例对象中会创建该函数的多个副本，因为每个实例对象都有一份副本，将方法存储于原型中优于存储在实例对象。</p><h3 id="第37-this变量的隐式绑定"><a href="#第37-this变量的隐式绑定" class="headerlink" title="第37 this变量的隐式绑定"></a><strong>第37 this变量的隐式绑定</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CSVReader.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = str.trim().split(<span class="regexp">/\n/</span>);</span><br><span class="line">    <span class="keyword">return</span> lines.map(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="keyword">this</span>.regexp);</span><br><span class="line">  &#125;,<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSVReader.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = str.trim().split(<span class="regexp">/\n/</span>);</span><br><span class="line">    <span class="keyword">return</span> lines.map(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="keyword">this</span>.regexp);</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;汇总《Effective JavaScript》68个有效方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;一、JavaScr
      
    
    </summary>
    
      <category term="前端" scheme="https://boxizen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://boxizen.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识梳理</title>
    <link href="https://boxizen.github.io/2016/02/14/javascript_summarize/"/>
    <id>https://boxizen.github.io/2016/02/14/javascript_summarize/</id>
    <published>2016-02-13T16:00:00.000Z</published>
    <updated>2018-07-01T02:58:33.770Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>本文梳理了JavaScript常见语言特性，以此巩固和加深自己对知识的理解。</p></blockquote><h2 id="一、作用域和内存管理"><a href="#一、作用域和内存管理" class="headerlink" title="一、作用域和内存管理"></a>一、作用域和内存管理</h2><h3 id="作用域-amp-amp-作用域链"><a href="#作用域-amp-amp-作用域链" class="headerlink" title="作用域&amp;&amp;作用域链"></a><strong>作用域&amp;&amp;作用域链</strong></h3><p>每一个<strong>执行环境</strong>都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个对象中。</p><p>全局函数无法查看局部函数的内部细节，但是局部函数却可以访问上层的执行环境，直至全局执行环境，当需要在局部函数中访问某一属性或方法的时候，如果在当前的变量对象中找不到，就会在上层作用域中查找，直至全局函数，这种组织形式就是<strong>作用域链</strong>。</p><h3 id="垃圾收集策略"><a href="#垃圾收集策略" class="headerlink" title="垃圾收集策略"></a>垃圾收集策略</h3><p>JavaScript是一门具有自动垃圾回收机制的编程语言，开发人员不必关心内存的分配和回收问题。对于垃圾回收机制的原理很简单，就是找出那些不再继续使用的变量，然后释放其占用的内存即可。</p><p><strong>(1) 标记清除</strong></p><p>JavaScript中最常用的垃圾收集方式为标记清除，当变量进入环境(如在函数中声明一个变量)时，将此变量标记为”进入环境”，而当其离开环境时(函数执行完毕)，则将其标记为”离开环境”。</p><p>标记的方法可以通过翻转某个特殊位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。</p><p><strong>(2) 引用计数</strong></p><p>另一种不太常见的垃圾收集策略叫做引用计数，其含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，相反，如果包含这个引用的变量又取了另外一个值，则这个值的引用次数减1，当这个值引用次数变成0时，则说明无法再访问这个值了，因而其占用的内存空间会被回收。</p><p>这种策略有一个致命的缺点在于，当存在两个变量相互引用时，他们的引用次数将永远不为0，因而其占用的内存永远不会被释放。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><p>闭包是指有权访问另一函数作用域中变量和对象的函数，一般表现为函数内部的函数。</p><p>使用闭包的优点如下:</p><p><strong>(1) 延长作用域链</strong></p><p>由于闭包可以访问外部函数中的变量和对象，因此可达到延长作用域链的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> out = <span class="string">'外部变量'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 模仿块级作用域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">if</span>(now.getMonth() == <span class="number">0</span> &amp;&amp; now.getDate() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Happy new year'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>该做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链了。</p><p>当然闭包也存在着不足之处, 具体如下:</p><ul><li><p>(1) 增加了内存消耗。</p></li><li><p>(2) IE浏览器由于垃圾回收机制问题，有内存溢出的风险。</p></li><li><p>(3) 增加了代码的复杂度，不容易维护或调试。</p></li></ul><h2 id="二、面向对象编程"><a href="#二、面向对象编程" class="headerlink" title="二、面向对象编程"></a>二、面向对象编程</h2><h3 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型&amp;&amp;原型链"></a><strong>原型&amp;&amp;原型链</strong></h3><p>在JavaScript中，我们创建的所有函数都含有一个<strong>prototype</strong>的属性，这个属性是一个指针，指向一个对象，这个对象就是<strong>原型对象</strong>。原型对象作用是让该函数派生出来的所有实例均能共享其属性和方法。（<em>注:实例中有<strong><strong>proto</strong></strong>属性，该属性指向原型对象，而原型对象中的constuctor属性泽指向原来的函数。</em>）</p><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例斗包含一个指向原型对象的内部指针(<strong>proto</strong>)。假如让原型对象等于另一个类型的实例，则它将包含一个指向另一个原型对象的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，上述关系依然成立，如此层层递进，就构成了实例和原型的链条，也就是<strong>原型链 </strong>。</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a><strong>对象创建</strong></h3><p><strong>(1) 工厂模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br></pre></td></tr></table></figure><p>不足: 无法判断对象的类别。</p><p><strong>(2) 构造函数模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>, <span class="number">26</span>, <span class="string">'teacher'</span>);</span><br></pre></td></tr></table></figure><p>不足: 主要问题在于，构造函数中的方法需要在每一个实例上重新创建一遍，造成内存资源的浪费。</p><p><strong>(3) 原型模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 重新给prototype赋值，同时constuctor重新指向原来的构造函数</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'boxizen',</span><br><span class="line">  age: 24,</span><br><span class="line">  job: 'student',</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br></pre></td></tr></table></figure><p>不足: 原型模式的主要缺点在于对于引用型的属性来说，由于其被所有的实例对象共享，所以其中一个实例对象修改了引用型属性就会导致所有实例对象引用的属性发生改变，而这违反了面向对象中封装特性。</p><p><strong>(4) 组合使用构造函数模式和原型模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelly'</span>, <span class="string">'pt'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>, <span class="number">26</span>, <span class="string">'teacher'</span>);</span><br></pre></td></tr></table></figure><p>这是当前在ECMAScript中使用最广泛、认可度最高的一种创建自定义类型的方法。</p><h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>继承是面向对象语言中一个最为津津乐道的概念，许多OO语言对支持两种方式的继承：接口继承和实现继承，其中接口继承只继承方法签名，而实现继承则继承实际的方法。由于ECMAScript中没有方法签名，所以只支持实现继承，在ECMAScript中通过<strong>原型链(参考前面)</strong>来实现继承的。</p><p><strong>(1) 原型继承</strong></p><p>ECMAScript中将原型链作为实现继承的主要方法。其主要思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型方法</span></span><br><span class="line">SuperType.prototype.getSuperValue = funtion() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类原型指向父类实例</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 子类原型方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类实例</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSUperValue());</span><br></pre></td></tr></table></figure><p>不足: 原型继承最大的问题来自于包含引用类型值的原型。前面提到了包含引用类型值的属性会被所有实例共享，所以为什么属性在构造函数中定义，而不是在原型对象中定义的原因；在通过原型实现继承的时候，实例属性变成了原型属性，所以造成了包含引用类型的属性被所有实例继承的现象。</p><p><strong>(2) 借用构造函数</strong></p><p>借用构造函数实现继承的思路很简单，就是在子类构造函数中调用超类型构造函数，以实现继承超类型属性方法的目的，解决了原型继承中所带来引用类型的问题。而这一过程主要依靠<strong>call</strong>或<strong>apply</strong>来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SUperType</span></span><br><span class="line">  SUperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'yellow'</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SUbType();</span><br><span class="line">instance2.colors.push(<span class="string">'purple'</span>);</span><br></pre></td></tr></table></figure><p>不足: 借用构造继承的问题还是在于，前面所说的，方法都在构造函数中定义，因此函数复用无从谈起，同时也对内存资源造成了浪费。</p><p><strong>(3) 组合继承</strong></p><p>组合继承是将原型继承与借用构造继承结合在一起，避免两者的缺陷，发挥两者所长的一种继承模式，是JavaScript中最常用的继承模式。其主要思路是通过在子类构造函数调用超类构造函数，以实现对实例属性的继承，而通过原型链实现对原型属性和方法的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超类定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SuType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、BOM和客户端检测"><a href="#三、BOM和客户端检测" class="headerlink" title="三、BOM和客户端检测"></a>三、BOM和客户端检测</h2><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><strong>BOM</strong></h3><p><strong>(1) location对象</strong></p><p>location饰最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能，它既是window对象的属性，也是document对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|   属性名    |  例子      |   说明   |</span><br><span class="line">| :-----------: | :-----------:  |  :-----------:  |</span><br><span class="line">| hash |  #contents  | 返回URL的hash|</span><br><span class="line">| host |  www.wrox.com:<span class="number">80</span>  | 返回服务器名和端口号(如果有)|</span><br><span class="line">| hostname |  www.wrox.com  | 返回不带端口号的服务器名|</span><br><span class="line">| port |  <span class="number">80</span> | 返回端口号|</span><br><span class="line">| href |  http:<span class="comment">//www.wrox.com  | 返回完成URL，与location.toString()返回值一样|</span></span><br><span class="line">| pathname |  <span class="regexp">/boxizen/</span>  | URL中目录或文件名|</span><br><span class="line">| protocol |  http:  | 返回URI的协议|</span><br><span class="line">| search |  ?q=javascript  | 返回查询字符串|</span><br></pre></td></tr></table></figure><p><strong>(2) navigator对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|   属性名    |  说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| appName|  完整浏览器版本  |</span><br><span class="line">| userAgent|  浏览器的用户代理字符串  |</span><br><span class="line">| vendor|  浏览器品牌  |</span><br><span class="line">| language|  浏览器主语言  |</span><br><span class="line">| plugins|  浏览器安装的插件信息的数组  |</span><br><span class="line">| ...|  ...  |</span><br></pre></td></tr></table></figure><h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a><strong>检测插件</strong></h3><p>检测插件(IE无效):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> name = name.toLowerCase();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测IE中的插件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) history对象</strong></p><p>history对象保存着用户上网的历史记录，从窗口被打开那一刻起算起。</p><p>后退一页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line">history.back();</span><br></pre></td></tr></table></figure><p>前进一页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line">history.forward();</span><br></pre></td></tr></table></figure><p>跳转到历史记录中的某个页面，如果历史记录不包含该字符串，则该方法什么也不做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="string">'wrox.com'</span>);</span><br></pre></td></tr></table></figure><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a><strong>客户端检测</strong></h3><p><strong>(1) 能力检测</strong></p><p>最常用也是最被广泛接受的客户端检测形式，通过判断浏览器的能力来识别浏览器的范围。</p><p><strong>(2) 怪癖检测</strong></p><p>通过识别浏览器的特殊行为判断特定的浏览器。而通常这些特殊行为表现为浏览器的BUG，譬如在IE8及更早的版本中存在一个BUG，即如果某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么改实例属性将不会出现在for-in循环中。</p><p><strong>(3) 用户代理检测</strong></p><p>在客户端，用户代理检测被看作是万不得已才用的做法，优先级排在能力检测和怪癖检测之后，原因在于浏览器经常使用<strong>电子欺骗</strong>的手段(在用户代理字符串中加入一些错误或误导性信息)欺骗服务器，以达到站点正确访问的目的。</p><p>用户代理检测的做法是通过<strong>navigator.userAgent</strong>属性得到代理字符串的值，再通过给该值做正则匹配以达到识别客户端浏览器的目的。</p><h2 id="四、DOM及其拓展"><a href="#四、DOM及其拓展" class="headerlink" title="四、DOM及其拓展"></a>四、DOM及其拓展</h2><p>DOM(文档对象模型)是针对HTML和XML文档的一个API，它描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p><h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a><strong>节点层次</strong></h3><p><strong>(1) Node类型</strong></p><p>DOM1级定义了一个Node接口，JavaScript中的所有节点类型都继承于该类型，因此所有节点类型都共享着相同的基本属性和方法，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法名    | 说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| **childNodes** |   获取第一个子节点|</span><br><span class="line">| parentNode |  获取父节点|</span><br><span class="line">| previousSibling |  获取上一个兄弟节点|</span><br><span class="line">| nextSibling |  获取下一个兄弟节点|</span><br><span class="line">| hasChildNodes() | 返回是否包含子节点|</span><br><span class="line">| appendChild() |  在最后插入子节点|</span><br><span class="line">| replaceChild() | 代替子节点|</span><br><span class="line">| removeChild() |  删除子节点|</span><br><span class="line">| insertBefore() | 在特定节点前面插入|</span><br></pre></td></tr></table></figure><p><strong>(2) Document类型</strong></p><p>JavaScript通过Document类型表示文档，Document节点nodeType为<strong>9</strong>, nodeName为<strong>#document</strong>，常见的属性及方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法名    | 说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| body |  指向&lt;body&gt;元素|</span><br><span class="line">| doctype |  指向&lt;!DOCTYPE&gt;元素|</span><br><span class="line">| title |  文档标题|</span><br><span class="line">| url |  文档所在的完整url |</span><br><span class="line">| referer |  来源页面的URL|</span><br><span class="line">| getElementById() |  取得id对应的元素|</span><br><span class="line">| getElementsByTagName() |  取得某个标签的元素集合|</span><br></pre></td></tr></table></figure><p><strong>(3) Element类型</strong></p><p>Element类型是Web编程中最常用的类型之一，因为它提供了对元素标签名、子节点及特性的访问，它的nodeType为<strong>1</strong>, nodeName为<strong>元素的标签名</strong>。</p><ul><li>HTML元素</li></ul><p>所有HTML元素都由HTMLElement类型表示，HTML元素继承于Element并添加了一些默认属性，因此可以直接访问这些属性，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.id);</span><br><span class="line"><span class="built_in">console</span>.log(div.className);</span><br><span class="line"><span class="built_in">console</span>.log(div.title);</span><br><span class="line"><span class="built_in">console</span>.log(div.lang);</span><br><span class="line"><span class="built_in">console</span>.log(div.dir);</span><br></pre></td></tr></table></figure><ul><li>取得属性</li></ul><p>在使用自定义属性的时候，可以通过getAttribute()方法取得该属性的值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-custom'</span>));</span><br></pre></td></tr></table></figure><ul><li>设置属性</li></ul><p>与getAttribute()相对应:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(<span class="string">'data-custom'</span>, <span class="string">'hehe'</span>);</span><br></pre></td></tr></table></figure><ul><li>attributes属性</li></ul><p>常用方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法名    | 说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| getNamedItem(name) |  获得nodeName为name的节点|</span><br><span class="line">| removeNamedItem(name) |  从属性列表移除nodeName为name的节点|</span><br><span class="line">| setNamedItem(name) |  添加节点，并以nodeName作为索引|</span><br><span class="line">| item(pos) |  返回位于数字pos位置处的节点|</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">'id'</span>).nodeValue;</span><br><span class="line"> element.attributes[i].nodeName;</span><br><span class="line"> element.attributes[i].nodeValue;</span><br></pre></td></tr></table></figure><ul><li>创建元素</li></ul><p>使用document.createElement()创建新的元素:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">div.id = <span class="string">'myDiv'</span>;</span><br><span class="line">div.className = <span class="string">'box'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><p><strong>(4) Text类型</strong></p><p>文本节点由Text表示，它的nodeType为<strong>3</strong>, nodeName为<strong>#text</strong>, 创建方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.className = <span class="string">'msg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;hello&lt;/stong&gt;"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.append(element);</span><br></pre></td></tr></table></figure><p><strong>(5) Attr类型</strong></p><p>元素属性在DOM中以Attr类型表示，它的nodeType为<strong>2</strong>，nodeName是<strong>属性的名称</strong>创建方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">'align'</span>);</span><br><span class="line">attr.value = <span class="string">'left'</span>;</span><br><span class="line"></span><br><span class="line">element.setAttribute(attr);</span><br><span class="line">element.getAttribute(<span class="string">'align'</span>);</span><br><span class="line">element.attributes[<span class="string">'align'</span>].nodeValue;</span><br></pre></td></tr></table></figure><p><strong>(6) DocumentFragment类型</strong></p><p>在所有的节点类型中，只有DocumentFragment在文档中没有对应的标记。DOM规定DocumentFragment是一种“轻量级文档”，可以包含和控制节点，但却不会像完整的文档那样占用额外的资源。nodeType为<strong>11</strong>, nodeName为<strong>#document-fragment</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"> li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + (i+<span class="number">1</span>)));</span><br><span class="line"> fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>由此也可以看出，使用DocumentFragment可以减少因频繁插入dom元素而带来的资源消耗，减少了dom结构的重排次数，从而得到了更高效的性能提升。</p><p><strong>(7) 其它类型</strong></p><p>其它类型还包括<strong>Comment类型</strong>、<strong>CDATASelection</strong>和<strong>DocumentType类型</strong>，因使用频率较低，故不做总结。</p><h3 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a><strong>DOM操作技术</strong></h3><p><strong>(1) 动态脚本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"> script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">  script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line"> &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">  script.text = code;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 动态样式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">css</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line"> style.type = <span class="string">'text/css'</span>;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">  style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line"> &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">  style.styleSheet.cssText = css;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 操作表格</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">'100%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'cell 1,1'</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'cell 2,1'</span>));</span><br></pre></td></tr></table></figure><h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a><strong>DOM扩展</strong></h3><p>尽管DOM作为API意境非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩展。对DOM的主要两个扩展是<strong>Selectors API</strong>和<strong>HTML5</strong>。</p><p><strong>(1) Selectors API</strong></p><p>Selectors API是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS查询。所有实现这一功能的JavaScript库都会写一个基础的CSS解析器，然后再使用已有的DOM方法查询文档并找到匹配的节点。而把这个功能变成原生API后，解析和树查询操作可以在浏览器内部通过编译后的代码完成，极大地改善了性能。</p><ul><li><strong>querySelector()方法</strong></li></ul><p>接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDIV = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>querySelectorAll()方法</strong></li></ul><p>与querySelector()一样，不过返回的是一个NodeList的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).querySelectorAll(<span class="string">'em'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>matchesSelector()方法</strong></li></ul><p>这个地方接收一个参数，即CSS选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.body.matchesSelector(<span class="string">'body.page1'</span>)) &#123;</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) HTML5</strong></p><ul><li><strong>与类相关的扩充</strong></li></ul><p>getElementsByClassName()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得所有类中包含'username'和'current'的元素，类名先后顺序无所谓</span></span><br><span class="line"><span class="keyword">var</span> name =  <span class="built_in">document</span>.getElementsByClassName(<span class="string">'username current'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>焦点管理</strong></li></ul><p>H5中添加了DOM焦点的功能，包括<strong>document.activeElement</strong>和<strong>hasFocus()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">button.focus();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>HTMLDocument的变化</strong></li></ul><p>H5把<strong>readyState</strong>、<strong>compatMode</strong>和<strong>head</strong>属性添加进标准:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档加载进度</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line"> <span class="comment">// 文档加载完毕</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染页面模式</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line"> <span class="comment">// 标准模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文档头部</span></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>插入标记</strong></li></ul><p><strong>innerHTML</strong>和<strong>outerHTML</strong>属性，避免了插入元素时频繁创建节点以及处理节点间关系的繁琐步骤，带来了极大的便利，但是需要谨慎其带来的性能消耗问题。</p><ul><li><strong>其它</strong></li></ul><p>此外H5还添加了字符集属性、自定义属性和scrollIntoView()等dom相关的属性及方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.charset); <span class="comment">//UTF-16</span></span><br><span class="line"><span class="built_in">document</span>.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据属性</span></span><br><span class="line">&lt;div id=<span class="string">'myDiv'</span> data-appId=<span class="string">'1234'</span> data-myName=<span class="string">'boxizen'</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="comment">// 取得自定义属性值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId;</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myName;</span><br><span class="line"><span class="comment">// 设置自定义属性值</span></span><br><span class="line">div.dataset.appId = <span class="string">'12345566'</span>;</span><br><span class="line">div.dataset.myName = <span class="string">'boxi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让元素可见</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView();</span><br></pre></td></tr></table></figure><h2 id="五、事件机制"><a href="#五、事件机制" class="headerlink" title="五、事件机制"></a>五、事件机制</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a><strong>事件流</strong></h3><p>事件流指的是从页面中接收事件的顺序，在IE和Netscape开发团队中提出了差不多完全相反的事件流的概念，其中IE的事件流是<strong>事件冒泡流</strong>, 而Netscape的事件流是<strong>事件捕获流</strong>。</p><p><strong>(1) 事件冒泡</strong></p><p>IE的事件流称为<strong>事件冒泡</strong>，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点(文档)。事件接收的顺序如下(以点击页面中某一div为例):</p><p><img src="/img/posts/js_summary/bubble.png" alt="事件冒泡"></p><p><strong>(2) 事件捕获</strong></p><p>Netscape Communicator团队提出的另一种事件流叫<strong>事件捕获</strong>，它的思想是不太具体的节点应该更早接收到事件，而具体的节点应该最后接收到事件，它的用意在于在事件到达预定目标之前捕获它。事件接收顺序如下:</p><p><img src="/img/posts/js_summary/catch.png" alt="事件捕获"></p><p><strong>(3) DOM事件流</strong></p><p>“DOM2级事件”规定的事件流包括三个阶段: 事件捕获阶段、处于目标阶段和事件冒泡阶段。仍以前面简单的HTML页面为例，单击div元素会按照下图所示的顺序触发事件:</p><p><img src="/img/posts/js_summary/event-w3c.png" alt="DOM事件流"></p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a><strong>事件处理程序</strong></h3><p>事件是用户或浏览器自身执行的某个动作，而响应某个事件的函数就叫做<strong>事件处理程序(或事件侦听)</strong>。</p><p><strong>(1) HTML事件处理程序</strong></p><p>在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其它地方定义的脚本:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;input type="button" value='Click Me' onclick='showMsg()'&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式有两个缺点，首先是存在<strong>时差问题</strong>, 用户可能会在元素一出现在页面就触发响应的事件，但当时的事件处理程序可能不具备执行条件。另一个缺点是HTML与JavaScript代码<strong>紧密耦合</strong>, 造成维护的困难。</p><p><strong>(2) DOM0级事件处理程序</strong></p><p>通过JavaScript指定事件处理程序就是把一个方法赋值给一个元素的事件处理程序属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">'Click Me'</span> id=<span class="string">'btn'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>如此处理，事件处理程序在元素的作用域下运行，this就是当前元素，还有一个好处，可以直接给onclick属性赋值为null删除事件处理程序。</p><p><strong>(3) DOM2级事件处理程序</strong></p><p>DOM2级事件处理程序定义了两个方法用于处理指定和删除事件处理程序的操作: <strong>addEventListener</strong>和<strong>removeEventListener</strong>。<br>它们都接收三个参数: 时间类型、事件处理方法和一个布尔值(true表示在事件捕获阶段调用事件处理程序，默认为false)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">'Click Me'</span> id=<span class="string">'btn'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> <span class="comment">// 添加第一个事件监听</span></span><br><span class="line"> btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click it!'</span>);</span><br><span class="line"> &#125;, <span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 添加第二个事件监听</span></span><br><span class="line"> <span class="keyword">var</span> clickEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hehehe'</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> btn.addEventListener(<span class="string">'click'</span>, clickEvent, <span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 删除第二个监听事件</span></span><br><span class="line"> btn.removeEventListenr(<span class="string">'click'</span>, clickEvent, <span class="literal">true</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这么做有的好处是可以为一个元素添加<strong>多个事件监听</strong>。</p><p>IE不支持addEventListener和removeEventListener两个方法，但是它却实现了类似的两个方法<strong>attachEvent</strong>和<strong>detachEvent</strong>，由于IE8及其更早的版本只支持事件冒泡，所以通过attachEvent添加的事件处理程序都会被添加到冒泡阶段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">'Click Me'</span> id=<span class="string">'btn'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 添加事件监听</span></span><br><span class="line"> btn.attachEvent(<span class="string">'onclick'</span>, handler);</span><br><span class="line"> <span class="comment">// 删除监听事件</span></span><br><span class="line"> btn.detachEvent(<span class="string">'onclick'</span>, handler);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，与DOM0的事件处理程序不同的是，DOM0事件处理程序会在其所属元素的作用域内运行，而在使用attachEvent()情况下，事件处理程序会在全局作用域内运行。并且在使用attachEvent()为某元素添加多个事件的时候，当事件触发时，会以添加事件时<strong>相反的</strong>顺序执行事件处理程序，这一点是跟DOM1事件处理不同的。</p><p><strong>(4) 跨浏览器事件处理程序</strong></p><p>根据上述事件处理程序的特点，可以写出如下兼容各个浏览器的事件处理程序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"> addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line">   element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent) &#123;</span><br><span class="line">   element.attachEvent(<span class="string">'on'</span>+type, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   element.[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> removeHandler: fuction(element, type, handler) &#123;</span><br><span class="line">  <span class="keyword">if</span>(element.removeListener) &#123;</span><br><span class="line">   element.removeListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent) &#123;</span><br><span class="line">   element.detach(<span class="string">'on'</span> + type, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><strong>事件对象</strong></h3><p><strong>(1) DOM事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法    | 类型   | 读/写 | 说明 |</span><br><span class="line">| :-----------: | :-----------:  | :-----------:  | :-----------:  |</span><br><span class="line">| bubbles| <span class="built_in">Boolean</span>| 只读| 表明事件是否冒泡 |</span><br><span class="line">| cancelable| <span class="built_in">Boolean</span>| 只读| 表明是否可以取消事件的默认行为 |</span><br><span class="line">| currentTarget| Element| 只读| 其事件处理程序当前正在处理事件的那个元素 |</span><br><span class="line">| detail| Integer| 只读| 与事件相关的细节信息 |</span><br><span class="line">| eventPhase| Integer| 只读| 调用事件处理程序的阶段:<span class="number">1</span>捕获,<span class="number">2</span>:目标,<span class="number">3</span>:冒泡 |</span><br><span class="line">| preventDefault()| <span class="built_in">Function</span>| 只读| 取消默认行为，如果cancelable为<span class="literal">true</span>，则可调用该方法 |</span><br><span class="line">| stopPropagation()| <span class="built_in">Function</span>| 只读| 取消事件的进一步捕获或冒泡，如果bubles为<span class="literal">true</span>，则可调用该方法 |</span><br><span class="line">| target| Element| 只读| 事件的目标 |</span><br><span class="line">| type| <span class="built_in">String</span>| 只读| 被触发的事件类型 |</span><br><span class="line">| ... | ... | ... | ... |</span><br></pre></td></tr></table></figure><p><strong>(2) IE中的事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法    | 类型   | 读/写 | 说明 |</span><br><span class="line">| :-----------: | :-----------:  | :-----------:  | :-----------:  |</span><br><span class="line">| cancelBubble| <span class="built_in">Boolean</span>| 读/写| 默认为<span class="literal">false</span>，但将其设置为<span class="literal">true</span>就可以取消事件冒泡,同**stopPropagation()** |</span><br><span class="line">| returnValue| <span class="built_in">Boolean</span>| 读/写| 默认为<span class="literal">true</span>，但将其设置为<span class="literal">false</span>就可以取消默认行为,同**preventDefault()** |</span><br><span class="line">| srcElement| Element| 只读| 事件的目标,同**target** |</span><br><span class="line">| type | <span class="built_in">String</span>| 只读| 被触发的事件类型 |</span><br></pre></td></tr></table></figure><p><strong>(3) 跨浏览器的事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"> addHandler: funcrion(element, type, handler) &#123;</span><br><span class="line">  <span class="comment">// 参见上一部分</span></span><br><span class="line"> &#125;, </span><br><span class="line"> removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参见上一部分</span></span><br><span class="line"> &#125;,</span><br><span class="line"> getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line"> &#125;,</span><br><span class="line"> getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line"> &#125;,</span><br><span class="line"> preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(event.preventDefault) &#123;</span><br><span class="line"></span><br><span class="line">   event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(event.stopPropagation) &#123;</span><br><span class="line">   event.stopPropagation();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a><strong>事件类型</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|   事件    | 类型   | 说明 |</span><br><span class="line">| :-----------: | :-----------:  | :-----------:  |</span><br><span class="line">| load | UI | 页面完全加载触发(包括图像、js、css等外部资源)|</span><br><span class="line">| unload | UI | 文档被卸载后触发(用户从一个页面切换到另一个)|</span><br><span class="line">| resize | UI | 浏览器窗口大小调整触发|</span><br><span class="line">| scroll | UI | 滚动条滚动时触发，作用在windows对象上|</span><br><span class="line">| focus | 焦点 | 元素获得焦点时触发|</span><br><span class="line">| unfocus | 焦点 | 元素失去焦点时触发|</span><br><span class="line">| click | 鼠标 | 点击时触发|</span><br><span class="line">| dblclick | 鼠标 | 双击时触发|</span><br><span class="line">| mousedown | 鼠标 | 按下鼠标时触发|</span><br><span class="line">| mouseup | 鼠标 | 释放鼠标时触发|</span><br><span class="line">| mouseenter | 鼠标 | 鼠标移到特定元素时触发|</span><br><span class="line">| mouseleave | 鼠标 | 鼠标离开特定元素时触发|</span><br><span class="line">| mousemove | 鼠标 | 移动鼠标时时触发|</span><br><span class="line">| mousewheel | 滚轮 | 滚动滚轮时触发|</span><br><span class="line">| keydown | 键盘 | 用户按下键盘上任意键时触发，返回键盘的代码|</span><br><span class="line">| keyup | 键盘 | 用户释放键盘上任意键时触发|</span><br><span class="line">| keypress | 键盘 | 用户按下键盘上任意键时触发，返回ASCII字符|</span><br><span class="line">| hashchange | HTML5 | hash值改变时触发|</span><br><span class="line">| orientationchange | 设备 | safari查看模式旋转时触发|</span><br><span class="line">| deviceorientation | 设备 | 设备方向变化时触发|</span><br><span class="line">| devicemotion | 设备 | 设备移动时时触发|</span><br></pre></td></tr></table></figure><h3 id="事件代理和委托"><a href="#事件代理和委托" class="headerlink" title="事件代理和委托"></a><strong>事件代理和委托</strong></h3><p>在JavaScript中，添加到页面上事件的数量直接影响页面的整体运行性能，导致这一问题原因主要是，每一个<strong>函数都是对象</strong>，都会占用内存，内存中对象越多，性能就越差。</p><p>对“事件处理程序过多”问题的解决方案就是<strong>事件委托</strong>，它利用了<strong>事件冒泡</strong>，达到了只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><p>如给某一列表下所以选项添加事件可以这么写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'myLinks'</span>);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(list, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> event = EventUtil.getEvent(event);</span><br><span class="line"> <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'dosomething'</span>:</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'gosomewhere'</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'go somewhere'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">'sayhi'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用事件委托/代理的优点主要有:</p><ul><li><p>可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件，从而提升页面的整体运行性能。</p></li><li><p>可以实现新增子对象时的动态事件绑定，不需要再给新增的元素单独添加事件。</p></li></ul><h3 id="事件模拟"><a href="#事件模拟" class="headerlink" title="事件模拟"></a><strong>事件模拟</strong></h3><p><strong>(1) DOM中的事件模拟</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line"><span class="comment">// 初始化事件对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p><strong>(2) IE中的事件模拟</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">'myTextBox'</span>);</span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEventObject();</span><br><span class="line"><span class="comment">// 初始化事件对象</span></span><br><span class="line">event.altKey = <span class="literal">false</span>;</span><br><span class="line">event.ctrlKey = <span class="literal">false</span>;</span><br><span class="line">event.shiftKey = <span class="literal">false</span>;</span><br><span class="line">event.keyCode = <span class="number">65</span>;</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.fireEvent(<span class="string">'onkeypress'</span>, event);</span><br></pre></td></tr></table></figure><h2 id="六、错误处理机制"><a href="#六、错误处理机制" class="headerlink" title="六、错误处理机制"></a>六、错误处理机制</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h3><p>由于JavaScript本身是动态语言，且多年来一直没有固定的开发工具，因此人们普遍认为它是一种最难调试的编程语言，抛出的错误没有上下文信息，让人摸不着头脑，而在ECMAScript3中引入了一套错误处理机制，意在帮助开发者更好地处理错误，更好地避免错误的发生。</p><p>ECMA-262定义了如下7种错误:</p><ul><li><p>Error, 基类型，其他错误类型都继承自该类型。</p></li><li><p>EvalError, 在使用eval()函数时发生异常时抛出。</p></li><li><p>RangeError, 数值超出相应范围时触发。</p></li><li><p>ReferenceError, 在找不到对象的情况下抛出。</p></li><li><p>SyntaxError, 语法错误时抛出。</p></li><li><p>TypeError, 在执行特定类型操作的时候，变量类型不符合要求时抛出。</p></li><li><p>URIError, URI格式错误时抛出。</p></li></ul><p><strong>(1) try-catch语句</strong></p><p>JavaScript中处理错误标准的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> someFunction();</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line"> <span class="keyword">if</span>(error <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理类型错误</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(error <span class="keyword">instanceof</span> <span class="built_in">ReferenceError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理引用错误</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 其他类型错误</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) throw语句</strong></p><p>与try-catch语句相配，用于随时抛出自定义错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">'CustomError'</span>;</span><br><span class="line"> <span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">'my massage'</span>);</span><br></pre></td></tr></table></figure><p><strong>(3) 错误(error)事件</strong></p><p>任何没有通过try-catch处理的错误都会触发window对象的error事件，onerror事件处理程序不会创建event对象，但它接收三个参数: <strong>错误消息</strong>、<strong>错误所在URL</strong>和<strong>错误行号</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line</span>) </span>&#123;</span><br><span class="line"> alert(message);</span><br><span class="line"> <span class="comment">// 阻止浏览器默认行为</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) 错误记录到服务器</strong></p><p>开发Web应用程序过程中一种常见的做法，就是集中保存错误日志，以便找重要错误的原因。而在复杂的程序员，通过把前端JavaScript错误集中汇报给后端也显得同样重要，常见的做法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params">sev, msg</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"> img.src = <span class="string">'log.php?sev='</span> + <span class="built_in">encodeURIComponent</span>(sev) + <span class="string">'&amp;msg='</span> + <span class="built_in">encodeURIComponent</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">// 可能出错的操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line"> logError(<span class="string">'nonfatal'</span>, ex.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Image发送请求的好处有:</p><ul><li><p>所有浏览器都支持Image对象，包括那些不支持XMLHttpRequest对象的浏览器</p></li><li><p>可以避免跨域限制。</p></li><li><p>在记录错误过程中出问题的概率比较低。</p></li></ul><h3 id="错误调试"><a href="#错误调试" class="headerlink" title="错误调试"></a><strong>错误调试</strong></h3><p><strong>(1) 控制台输出</strong></p><p>主要手段是通过console.log将信息输出至控制台中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">console</span> == <span class="string">'object'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> opera == <span class="string">'object'</span>) &#123;</span><br><span class="line">  opera.postError(message);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure><p><strong>(2) 页面输出</strong></p><p>在页面上直接输出错误信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="built_in">console</span> = <span class="built_in">document</span>.getElementById(<span class="string">'debuginfo'</span>);</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">console</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span> = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line">  <span class="built_in">console</span>.id = <span class="string">'debuginfo'</span>;</span><br><span class="line">  <span class="built_in">console</span>.style.border = <span class="string">'1px solid #000'</span>;</span><br><span class="line">  .....</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(<span class="built_in">console</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.innerHTML += <span class="string">'&lt;p&gt;'</span> + message + <span class="string">'&lt;/p&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 错误抛出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">condition, message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(!condition) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(<span class="keyword">typeof</span> num1 == <span class="string">'number'</span> &amp;&amp; obj1 <span class="keyword">instanceof</span> <span class="built_in">Number</span>, <span class="string">'类型错误'</span>);</span><br></pre></td></tr></table></figure><h2 id="七、JSON和AJAX"><a href="#七、JSON和AJAX" class="headerlink" title="七、JSON和AJAX"></a>七、JSON和AJAX</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><strong>JSON</strong></h3><p>曾经有一段时间，XML是互联网上传输结构化数据的事实标准，然而业界一直不乏质疑XML的声音，他们认为XML结构臃肿，操作繁琐，而JSON的出现，让这些开发者看到了更加轻量、操作便捷的数据交换格式，并开始广泛使用这种结构化数据，渐渐地，JSON已经取代了XML，成为时下在互联网上最流行的数据传输格式。</p><p><strong>(1) 语法</strong></p><p>JSON支持<strong>简单值</strong>、<strong>对象</strong>和<strong>数组</strong>三种类型的值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单值</span></span><br><span class="line"><span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"name"</span>: <span class="string">"boxizen"</span>,</span><br><span class="line"> <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">[</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"boxizen"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Lisi"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">42</span></span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>需要注意的是，JSON对象中属性名必须加上双引号。</p><p><strong>(2) 解析与序列化</strong></p><p>JSON对象有两个方法: <strong>stringify()</strong>和<strong>parse()</strong>, 这两个方法分别用于<strong>把JavaScript对象序列化为JSON字符串</strong>和<strong>把JSON字符串解析为JavaScript对象</strong>。</p><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h3><p>Ajax的技术核心是<strong>XMLHttpRequest</strong>，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现</p><p><strong>(1) XMLHttpRequest基本用法</strong></p><p><strong>XHR创建:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> xhr;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">  <span class="keyword">var</span> activexName = [ <span class="string">"MSXML2.XMLHTTP"</span>, <span class="string">"Microsoft.XMLHTTP"</span> ]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; activexName.length; i++) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(activexName[i]);</span><br><span class="line">    <span class="keyword">if</span>(xhr) &#123;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get请求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> req = createXHR();</span><br><span class="line"> <span class="keyword">if</span>(req) &#123;</span><br><span class="line">  req.open(<span class="string">"GET"</span>, <span class="string">"http://xxxxx"</span>, <span class="literal">true</span>);</span><br><span class="line">  req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 0未初始化，1启动，2发送，3接收部分数据，4接收到全部响应数据</span></span><br><span class="line">   <span class="keyword">if</span>(req.readState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.status == <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(req.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     alert(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  req.send(<span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>post请求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> req = createXHR();</span><br><span class="line"> <span class="keyword">if</span>(req) &#123;</span><br><span class="line">  req.open(<span class="string">'POST'</span>, <span class="string">'http://xxxx'</span>, <span class="literal">true</span>);</span><br><span class="line">  req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(req.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(req.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     alert(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  req.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">  req.send(serialize(form));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) XMLHttpRequest扩展</strong></p><p>鉴于XMLHttpRequest已经得到广泛使用，成为了事实标准，W3C也着手制定相应标准以规范其行为，XHR1级把已有的XHR对象的实现细节描述了出来，而XHR2级将继续拓展功能。</p><p><strong>FormData</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'boxizen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接传入表单元素</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">....</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://xxxx'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><p>使用FormData的方便之处在于不必明确地在XHR对象上设置请求头部，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong></p><p>IE8为XHR对象添加了timeout属性，表示请求在等待响应多少毫秒后就停止，同时会触发ontimeout事件，而此功能后来也被收入了XHR2级规范中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">....</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://xxxx'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 超时时间设为1秒</span></span><br><span class="line">xhr.timeout = <span class="number">1000</span>;</span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><h3 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a><strong>跨域资源共享</strong></h3><p>通过Ajax通信的一个主要限制，来自于跨域安全策略(同源策略)，即XHR对象只能访问同源(相同的协议、相同的域名和相同的端口)下的资源。这种安全策略从一定程度上可以防止恶意行为的出现，但是合理的跨域请求在某些开发场景下却显得格外重要。</p><p>为了解决<strong>跨域资源</strong>访问问题，W3C提出了<strong>CORS</strong>的工作草案, 即Cross-Origin Resource Sharing，它的基本思想是通过自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是应该成功还是失败的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发送Origin的请求头</span></span><br><span class="line">Origin: http:<span class="comment">//bignews.boxizen.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器通过Access-Control-Allow-Origin请求判断该请求是否被允许, </span></span><br><span class="line"><span class="comment">// 如果回应与Origin值相同的或者是"*"的值，则表示该请求被允许</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//bignews.boxizen.com/</span></span><br></pre></td></tr></table></figure><p><strong>(1) IE对CORS的实现</strong></p><p>IE为实现跨域请求，引入了<strong>XDR</strong>对象，即XDomainRequest, 它与XHR不同之处在于:</p><ul><li>cookie不会随请求发送，也不会随响应返回</li><li>只能设置头部信息中的Content-Type字段</li><li>不能访问响应的头部信息</li><li>只支持get/post方法</li></ul><p>具体实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(xdr.responseText);</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'errors!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与XHR不同的是，XDR的open方法只接收两个参数</span></span><br><span class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://bignews.boxizen.com/ajax/'</span>);</span><br><span class="line">xdr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>(2) 其他浏览器对CORS的实现</strong></p><p>其他的浏览器通过对XHR对象实现了跨域的支持，不过出现了一些限制：</p><ul><li>不能通过setRequestHeader()设置自定义头部</li><li>不能发送和接收cookie</li><li>调用getAllRequestHeaders()总会返回空字符串</li></ul><p><strong>(3) 跨浏览器的CORS</strong></p><p>每个浏览器对CORS的支持程度都不一样，但是所有的浏览器都支持简单的(不带自定义头部信息和凭据的)请求，因此有必要实现一套跨浏览器方案的跨域请求。通过判断XHR中是否包含<strong>“withCredentials”</strong>属性来判断是否支持CORS跨域。</p><p>创建跨浏览器的CORS请求对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method, url</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> <span class="keyword">if</span>(<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) &#123;</span><br><span class="line">  xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.XDomainRequest) &#123;</span><br><span class="line">  vxhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">  vxhr.open(method, url);</span><br><span class="line">  xhr = vxhr</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xhr = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送CORS请求:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">'get'</span>, <span class="string">'http://bignews.boxizen.com/ajax'</span>);</span><br><span class="line"><span class="keyword">if</span>(request) &#123;</span><br><span class="line"> request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line"> &#125;</span><br><span class="line"> request.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a><strong>其他跨域技术</strong></h3><p><strong>(1) 图像Ping</strong></p><p>我们知道，一个网页可以加载任何网页中的图像资源，利用这一点可以实现简单的跨域方式，这也是在线广告跟踪浏览量的主要方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'done!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'http://bignews.boxizen.com/statistics'</span>;</span><br></pre></td></tr></table></figure><p>这种方式有两种主要缺点:</p><ul><li>只能发送Get请求</li><li>不能获得服务器端响应的文本信息</li></ul><p><strong>(2) JSONP</strong></p><p>它由两部分组成：<strong>回调函数</strong>和<strong>json数据</strong>，格式看起来是这样的:</p><p><strong>callback({“name”: “boxizen”})</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleReponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'name:'</span> + response.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://bignews.boxizen.com/jsonp'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure><p>使用JSONP一个最大的优点是可以访问服务器端的响应，支持浏览器端和服务器端的双向通信。而它的缺点也是显而易见的:</p><ul><li>JSONP是从其他域中加载代码执行，如果其他域不安全，可能会在响应中夹带一些恶意代码，因此在使用不是你自己运维的web服务时，一定要保证它安全可靠</li><li>确定JSONP请求是否失败并不容易。</li></ul><h2 id="八、客户端存储"><a href="#八、客户端存储" class="headerlink" title="八、客户端存储"></a>八、客户端存储</h2><h3 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a><strong>离线检测</strong></h3><p>HTML5中定义了一个<strong>navigator.onLine</strong>属性，用于监测设备是否处理在线状态，为<strong>true</strong>即在线，为<strong>false</strong>即离线。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(navigator.onLine) &#123;</span><br><span class="line"> <span class="comment">// 正常工作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 执行离线状态时的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，HTML5还定义了两个事件:<strong>online</strong>和<strong>offline</strong>，当网络从离线变为在线或者从在线变为离线时分别触发这两个事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'online'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'online'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'offline'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>判断应用是否在线一般的做法是，在页面加载后，先通过navigator.onLine取得初始的状态，然后再通过上述两个事件确定网络的变化状态。</p><h3 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a><strong>应用缓存</strong></h3><p>HTML5的应用缓存(application cache),简称为appcache，是专门为开发离线Web应用设计的，是从浏览器缓存中分出来的一块缓存区。想使用这个缓存保存数据，可以使用一个<strong>描述文件(manifest file)</strong>，列出要下载和缓存的资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#Comment</span><br><span class="line"></span><br><span class="line">file.js</span><br><span class="line">file.css</span><br></pre></td></tr></table></figure><p>然后再将描述文件域页面关联起来，可以在</p><html>中的manifest属性中指定这个文件的路径，这个文件的MIME类型必须是<strong>text/cache-manifest</strong>:<p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=<span class="string">"/offline.manifest"</span>&gt;</span><br></pre></td></tr></table></figure><p>此外JavaScript中还提供了<strong>applicationCache</strong>的对象对离线资源进行操作和管理，此处略去。</p><h3 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a><strong>客户端存储</strong></h3><p>随着WebApp的出现，产生了对能够直接在客户端上存储用户信息能力的要求。</p><p><strong>(1) Cookie</strong></p><p>Cookie最初是在客户端存储会话信息的。</p><p><strong>(2) IE用户数据</strong></p><p><strong>(3) Web存储机制</strong></p><ul><li><p>sessionStorage对象</p></li><li><p>globalStorage对象</p></li><li><p>localStorage对象</p></li></ul><p><strong>(4) IndexedDB</strong></p></html><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;本文梳理了JavaScript常见语言特性，以此巩固和加深自己对知识的理解。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;一、作
      
    
    </summary>
    
      <category term="前端" scheme="https://boxizen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://boxizen.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP 学习笔记</title>
    <link href="https://boxizen.github.io/2015/12/25/http_protocol/"/>
    <id>https://boxizen.github.io/2015/12/25/http_protocol/</id>
    <published>2015-12-24T16:00:00.000Z</published>
    <updated>2018-07-01T02:58:17.195Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>去年7月份，本人有幸到了UC进行了长达近半年的实习，主要的工作内容为国际资讯爬虫，并在这当中零零散散接触到了许多HTTP协议相关知识，觉得有必要对其进行系统地学习，所以阅读了《图解HTTP》，并写下读书笔记。</p></blockquote><style>table{width:100%;border:1px solid #ddd;border-collapse:collapse;margin-bottom:20px}td,th{border:1px solid #ddd;padding:5px;font-size:.8rem}</style><h2 id="第1章-了解Web及网络基础"><a href="#第1章-了解Web及网络基础" class="headerlink" title="第1章 了解Web及网络基础"></a><strong>第1章 了解Web及网络基础</strong></h2><h3 id="HTTP的诞生"><a href="#HTTP的诞生" class="headerlink" title="HTTP的诞生"></a><strong>HTTP的诞生</strong></h3><p>互联网早期，Tim Berners-Lee博士提出了一种能让远隔两地研究者们共享知识的设想。该设想的基本理念是：借助多文档之间相互关联的超文本（HyperText），连成可相互参阅的WWW(World Wide Web, 万维网)。</p><p>为实现这种理念，提出了3项WWW的构建技术，分别是作为页面文本标记语言的HTML、作为文档传输协议的<strong>HTTP</strong>和指定文档所在地址的URL，<strong>HTTP协议</strong>因此而诞生。</p><h3 id="HTTP的发展"><a href="#HTTP的发展" class="headerlink" title="HTTP的发展"></a><strong>HTTP的发展</strong></h3><p>HTTP协议发展至今共经历了三个版本，如下所示:</p><ul><li><p>HTTP/0.9: HTTP于1990年问世，那时它并没有作为标准被建立，此时的版本含有HTTP/1.0之前版本的意思，因而被称为HTTP/0.9。</p></li><li><p>HTTP/1.0: HTTP被正式作为标准发布是在1996.05，命名为HTTP/1.0。</p></li><li><p>HTTP/1.1: 1997.01公布的HTTP/1.1是目前主流的HTTP协议版本，它与HTTP/1.0的主要区别是添加了持久连接，也就是可以在一个连接中传输多个对象。</p></li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a><strong>TCP/IP</strong></h3><p>与互联网相关的协议集合起来总称为TCP/IP。TCP/IP协议族里重要的一点是分层，其按照层次从上往下分别分为应用层、传输层、网络层和数据链路层，而各层的作用如下所示:</p><ul><li><p>应用层: 包含了所有高层协议，向用户提供了应用服务，如FTP、DNS、HTTP等。</p></li><li><p>传输层: 传输层提供了对于网络连接中两台计算机之间的数据传输，此层包含了两个性质不同的协议：TCP和UDP。</p></li><li><p>网络层: 处理在网络上流动的数据包，决定了数据包的传输路线。</p></li><li><p>链路层: 处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC以及光纤等物理可见部分。</p></li></ul><h3 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a><strong>其他协议</strong></h3><ul><li><strong>IP</strong></li></ul><p>IP协议位于网络层，作用是把各种数据包传送给远程机器，通过ARP协议找出IP地址所对应的MAC地址以达到传送的目的。</p><ul><li><strong>TCP</strong></li></ul><p>TCP位于传输层，提供可靠的字节流服务(把大块数据分割成以报文段为单位的数据包进行管理)。TCP采用三次握手策略确保数据准确无误地送达目标处。</p><ul><li><strong>DNS</strong></li></ul><p>位于应用层，提供从域名到IP地址或从IP地址到域名的服务。</p><ul><li><strong>URI/URL</strong></li></ul><p>URI用字符串标识某一互联网资源，而URL表示资源的地点。</p><h2 id="第2章-简单的HTTP协议"><a href="#第2章-简单的HTTP协议" class="headerlink" title="第2章 简单的HTTP协议"></a><strong>第2章 简单的HTTP协议</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><ul><li><p>应用HTTP协议时，一端充当客户端角色，另一端充当服务器角色，两端之间通过请求和响应的交换达成通信。</p></li><li><p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p></li><li><p>响应报文由协议版本、状态码、状态语、可选的响应首部字段以及实体主体构成。</p></li><li><p>HTTP是一种无状态的协议，即不对发送过的请求或响应做持久化处理。</p></li></ul><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a><strong>HTTP方法</strong></h3><ul><li><p>GET: 获取资源</p></li><li><p>POST: 传输实体主体</p></li><li><p>PUT: 传输文件</p></li><li><p>HEAD: 获得报文首部</p></li><li><p>DELETE: 删除文件</p></li><li><p>OPTIONS: 询问支持的方法</p></li><li><p>TRACE: 追踪路径</p></li><li><p>CONNECT: 要求用隧道协议连接代理</p></li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h3><p>在HTTP协议初始版本中，每进行一次HTTP通信都要进行TCP连接的建立和断开，造成了额外的开销，为了解决这种问题，HTTP/1.1提出了持久连接，又称为HTTP keep-alive，它的特点是，只要任意一段没有明确提出断开连接，则保持TCP的连接状态。也就是说，TCP的持久连接旨在建立一次TCP连接后进行多次HTTP请求与响应的交互。</p><p><strong>管线化技术</strong>的出现解决了多个HTTP的阻塞请求方式，使得多个HTTP请求能以并行的方式进行发送，提高了请求响应的效率。</p><h3 id="Cookie管理状态"><a href="#Cookie管理状态" class="headerlink" title="Cookie管理状态"></a><strong>Cookie管理状态</strong></h3><p>HTTP是无状态协议，本身不对已经发送过的请求与响应进行管理，为了解决这方面的不足，引入了Cookie技术，这是一种通过在请求与响应保温中写入Cookie信息来控制客户端状态的技术，Cookie会根据从服务器端发送的响应报文中的Set-Cookie的首部字段信息，通知客户端保存Cookie，，当客户端下一次向服务器发送请求时，会在请求报文中加入Cookie的信息发送，以通知服务器端识别是来自哪一个用户。</p><h2 id="第3章-HTTP报文"><a href="#第3章-HTTP报文" class="headerlink" title="第3章 HTTP报文"></a><strong>第3章 HTTP报文</strong></h2><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a><strong>报文结构</strong></h3><p>用于HTTP协议交互的信息被称为HTTP报文，其中请求端(客户端)的报文称为请求报文，而响应端(服务器端)的报文称为响应报文。</p><p>报文的结构由<strong>起始行(请求行/状态行)</strong>、<strong>首部(header)</strong>和<strong>主体(body)</strong>构成。</p><p><img src="/img/posts/http/structure.jpg" alt="http报文结构"></p><h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a><strong>编码提升传输速率</strong></h3><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中使用<strong>编码</strong>提升传输速率。</p><ul><li><strong>压缩传输</strong></li></ul><p>由服务器进行实体内容的压缩，内容传输完成后由客户端进行解码。常见的内容编码有:<br><strong>gzip(GNU zip)</strong>、<strong>compress(UNIX系统的标准压缩)</strong>、<strong>deflate(zlib)</strong>、<strong>identity(不进行编码)</strong>。</p><ul><li><strong>分块传输</strong></li></ul><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求的页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><ul><li><strong>多部分对象集合</strong></li></ul><p>一份报文主体内可含有多类型实体，通过Content-Type来标识。如<strong>multipart/form-data</strong>、<strong>multipart/byteranges</strong>。</p><ul><li><strong>范围请求</strong></li></ul><p>http中可以通过header中Range字段指定请求的范围，如Range: bytes=5001-10000。</p><ul><li><strong>内容协商</strong></li></ul><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p><p>内容协商技术包含:<strong>服务器驱动协商</strong>、<strong>客户端驱动协商</strong>和<strong>透明协商</strong>。</p><h2 id="第4章-返回结果的HTTP状态码"><a href="#第4章-返回结果的HTTP状态码" class="headerlink" title="第4章 返回结果的HTTP状态码"></a><strong>第4章 返回结果的HTTP状态码</strong></h2><h3 id="请求结果"><a href="#请求结果" class="headerlink" title="请求结果"></a><strong>请求结果</strong></h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">类别</th><th style="text-align:center">原因短语</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational(信息性状态码)</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success(成功状态码)</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection(重定向状态码)</td><td style="text-align:center">需求进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error(服务器错误状态码)</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h3><ul><li><strong>2XX 成功</strong></li></ul><p>200，表示从客户端发来的请求在服务器端被正常处理了。</p><p>204，请求处理成功，但是没有资源返回。</p><p>206，请求处理成功，返回部分内容，响应报文中包含Content-Range指定范围的实体内容。</p><ul><li><strong>3XX 重定向</strong></li></ul><p>301，永久性重定向，</p><p>302，临时性重定向。</p><p>303，表示请求的资源存在着另一个URL，应使用GET方法定向获取请求的资源。</p><p>304，表示请求的资源没有改变，可以使用客户端上未过期的资源。</p><p>307，临时性重定向，不会从POST变成GET。</p><ul><li><strong>4XX 客户端错误</strong></li></ul><p>400, Bad Request，表示请求报文中存在语法错误。</p><p>401, Unauthorized，表示发送的请求需要有通过HTTP认证。</p><p>403, Forbidden, 表示请求资源的访问被服务器拒绝了。</p><p>404, Not Found，表示服务器上没有请求的资源。</p><ul><li><strong>5XX 服务器错误</strong></li></ul><p>500, Internal Server Error，表示服务器在执行请求时发生了错误。</p><p>503, Service Unavailable，表示服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求。</p><h2 id="第5章-与HTTP协作的Web服务器"><a href="#第5章-与HTTP协作的Web服务器" class="headerlink" title="第5章 与HTTP协作的Web服务器"></a><strong>第5章 与HTTP协作的Web服务器</strong></h2><h3 id="虚拟主机实现多域名"><a href="#虚拟主机实现多域名" class="headerlink" title="虚拟主机实现多域名"></a><strong>虚拟主机实现多域名</strong></h3><p>HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，需要在Host首部指定主机名或域名的URI。</p><h3 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a><strong>通信数据转发程序</strong></h3><p>HTTP通信时，除了客户端和服务器以外，还有一些用语通信数据转发的应用程序，例如代理、网关和隧道。</p><ul><li><strong>代理</strong></li></ul><p>代理是一种具有转发功能的应用程序，它扮演了客户端与服务器之间中间人的角色，接收来自客户端的请求，并转发给目标服务器，同时接收目标服务器的响应并转发给客户端。</p><ul><li><strong>网关</strong></li></ul><p>网关是转发其他服务器通信数据的服务器，接收客户端请求时，就像自己拥有资源的服务器一样对请求进行处理。</p><ul><li><strong>隧道</strong></li></ul><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。它可按要求建立起一条与服务器相通的线路，并使用SSL灯加密手段进行通信，保证通信的安全性。</p><h2 id="第6章-HTTP首部"><a href="#第6章-HTTP首部" class="headerlink" title="第6章 HTTP首部"></a><strong>第6章 HTTP首部</strong></h2><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a><strong>HTTP首部字段</strong></h3><p>HTTP报文由三部分组成：起始行(请求行/响应行)、首部字段、报文主体，其中首部字段中包含的信息最为丰富，在客户端与服务器端以HTTP协议进行通信的过程中，首部字段传递着额外的重要信息。</p><p>4种HTTP首部字段类型: <strong>通用首部字段</strong>、<strong>请求首部字段</strong>、<strong>响应首部字段</strong>和<strong>实体首部字段</strong>。</p><p><strong>通用首部字段</strong></p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">连接管理</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文日期时间</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">追踪请求与响应报文经过的路径</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">告知用户一些与缓存相关的问题的警告</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">报文主体的传输编码方式</td></tr></tbody></table><p><strong>请求首部字段</strong></p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept</td><td style="text-align:center">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center">Accept-Charset</td><td style="text-align:center">优先的字符集</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:center">优先的内容编码</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:center">优先的语言</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">认证信息</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">请求资源所在服务器</td></tr><tr><td style="text-align:center">If-Match</td><td style="text-align:center">条件请求，查询与ETag值对应的资源</td></tr><tr><td style="text-align:center">If-None-Match</td><td style="text-align:center">条件请求，与If-Match相反</td></tr><tr><td style="text-align:center">If-Modified-Since</td><td style="text-align:center">资源修改 ? Last-Modified : 304 Not-Modified</td></tr><tr><td style="text-align:center">If-Unmodified-Since</td><td style="text-align:center">与If-Modified-Since相反, 在资源没有修改的情况下才返回</td></tr><tr><td style="text-align:center">If-Range</td><td style="text-align:center">其值若是跟ETag值或更新的日期时间匹配一致，则作为范围请求处理</td></tr><tr><td style="text-align:center">Range</td><td style="text-align:center">实体的字节范围请求</td></tr><tr><td style="text-align:center">Max-Forwards</td><td style="text-align:center">最大传输逐跳数</td></tr><tr><td style="text-align:center">Referer</td><td style="text-align:center">请求中URI的原始来源页面</td></tr><tr><td style="text-align:center">User-Agent</td><td style="text-align:center">HTTP客户端程序信息</td></tr></tbody></table><p><strong>响应首部字段</strong></p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">是否接受字节范围请求</td></tr><tr><td style="text-align:center">ETag</td><td style="text-align:center">资源的匹配信息</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">推算资源创建经过时间</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:center">令客户端重定向至指定的URI</td></tr><tr><td style="text-align:center">Proxy-Authentication</td><td style="text-align:center">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:center">Retry-After</td><td style="text-align:center">对再次发起请求的时机要求</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:center">HTTP服务器的安装信息</td></tr><tr><td style="text-align:center">Vary</td><td style="text-align:center">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">服务器对客户端的认证信息</td></tr></tbody></table><p><strong>实体首部字段</strong></p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:center">资源可支持的HTTP方法</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:center">实体主体适用的编码方式</td></tr><tr><td style="text-align:center">Content-Language</td><td style="text-align:center">实体主体的自然语言</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">实体主体的大小(单位：字节)</td></tr><tr><td style="text-align:center">Content-Location</td><td style="text-align:center">替代对应资源的URI</td></tr><tr><td style="text-align:center">Content-MD5</td><td style="text-align:center">实体主体的报文摘要</td></tr><tr><td style="text-align:center">Content-Range</td><td style="text-align:center">实体主体的位置范围</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">实体主体的媒体类型</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:center">实体主体过期的日期时间</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">资源的最后修改日期时间</td></tr></tbody></table><p><strong>Cookie相关首部字段</strong></p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Set-Cookie</td><td style="text-align:center">服务器端返回给客户端存储的Cookie信息</td></tr><tr><td style="text-align:center">Cookie</td><td style="text-align:center">客户端向服务器端发送Cookie信息</td></tr></tbody></table><p><strong>其他首部字段</strong></p><ul><li>X-Frame-Options</li><li>X-XSS-Protection</li><li>DNT</li><li>P3P</li></ul><h2 id="第7章-确保Web安全的HTTPS"><a href="#第7章-确保Web安全的HTTPS" class="headerlink" title="第7章 确保Web安全的HTTPS"></a><strong>第7章 确保Web安全的HTTPS</strong></h2><h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a><strong>HTTP的缺点</strong></h3><p>HTTP通信过程中的不足主要有以下几点:</p><ul><li><strong>通信使用明文传输，内容可能被窃听</strong></li></ul><p>服务器与客户端进行通信时，数据要经过许多通信线路中转才得以相通，但是我们无法保证通信线路上的某些网络设备都是个人私有物，因此不能够排除某一个环节糟心消息窃听。</p><ul><li><strong>不验证通信方的身份，有可能遭遇伪装</strong></li></ul><p>使用HTTP通信时，不存在通信方确认的处理步骤，任何人都可以发送请求，因此服务器只要收到请求，不管是谁都会返回一个响应。</p><ul><li><strong>无法证明报文的完整性，所以有可能已遭篡改</strong></li></ul><p>在使用HTTP协议进行双方通信时，常常遭遇攻击者拦截并篡改通信的内容(中间人攻击, Man-in-the-Middle attack, MITM)。</p><h3 id="HTTPS的诞生"><a href="#HTTPS的诞生" class="headerlink" title="HTTPS的诞生"></a><strong>HTTPS的诞生</strong></h3><p>为了解决上述HTTP中的几个不足之处，HTTPS应运而生。也就是说HTTPS完成了通信内容的加密、通信方身份认证以及通信报文完整性保护三大问题，我们把添加了加密及认证机制的HTTP称为HTTPS(HTTP Secure)。</p><p>HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议代替了，也就是说，HTTP由直接和TCP通信转变成了先让HTTP与SSL通信，再让SSL与TCP进行通信。因而又称HTTPS为<strong>披着SSL外壳的HTTP</strong>。</p><h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a><strong>加密技术</strong></h3><p>SSL采用一种叫做<strong>公开密钥加密的</strong>加密处理方式。近代的加密方法中加密算法是公开的，而密钥确实保密的，通过这种方式得以保持加密方法的安全。</p><ul><li><strong>共享密钥</strong></li></ul><p>加密和解密都使用同一个密钥的方式称为共享密钥加密(Common Key crypto system)，也被称作对称密钥加密。</p><p>该密钥加密方式存在一个很重要的问题，由于解密跟加密是使用同一把密钥，所以发送方必须把密钥发送给接收方，但是在传递密钥的这一过程中容易遭到信息窃取，而这就失去了信息加密的意义了。</p><ul><li><strong>使用两把密钥的公开密钥加密</strong></li></ul><p>公开密钥加密使用了两把非对称的密钥，一把叫做私有密钥，一把叫做公开密钥，公开密钥可以随意发布，而私有密钥则不能让任何人知道。</p><ul><li><strong>混合加密机制的HTTPS</strong></li></ul><p>由于公开密钥和共享密钥相比，其处理速度钥慢很多，所以在HTTPS的实际应用中，采用了两者所长以达到信息加密传输与解密的目的。主要表现为，在传输共享密钥时，采用了公开密钥的加密方式，而后的通信过程则使用共享密钥加密来进行。</p><h2 id="第8～10章-用户身份认证与HTTP相关协议技术"><a href="#第8～10章-用户身份认证与HTTP相关协议技术" class="headerlink" title="第8～10章 用户身份认证与HTTP相关协议技术"></a><strong>第8～10章 用户身份认证与HTTP相关协议技术</strong></h2><p>未完待续</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;去年7月份，本人有幸到了UC进行了长达近半年的实习，主要的工作内容为国际资讯爬虫，并在这当中零零散散接触到了许多HTTP协议相关知识
      
    
    </summary>
    
      <category term="网络" scheme="https://boxizen.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http 协议" scheme="https://boxizen.github.io/tags/http-%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>ios证书制作与打包发布</title>
    <link href="https://boxizen.github.io/2015/07/04/ios_cer/"/>
    <id>https://boxizen.github.io/2015/07/04/ios_cer/</id>
    <published>2015-07-03T16:00:00.000Z</published>
    <updated>2018-07-01T02:58:24.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>苹果的证书多样纷杂，且打包审核的过程严格复杂，各种身份验证，证书验证的操作相信已经把许多人搞晕，包括本人在内，最近一个项目需要打包上线，却因为这些非技术问题而把原计划拖延许久。看来记录笔记刻不容缓。(<strong>多图慎点</strong>)</p></blockquote><h3 id="1-生成CSR文件"><a href="#1-生成CSR文件" class="headerlink" title="1. 生成CSR文件"></a>1. 生成CSR文件</h3><p>CSR文件，全称CertificateSigningRequest，由本地生成，为请求苹果开发证书所用，操作流程如下：</p><p>在spotlight中搜索keychain,默认是第一条记录，点击打开钥匙串访问:<br><img src="/img/posts/apple/spotlight.png" alt="spotlight"></p><p>在钥匙串访问中选：择证书助理 －&gt; 从证书颁发机构请求证书:<br><img src="/img/posts/apple/keychain.png" alt="钥匙串访问"></p><p>填写邮箱信息并把CSR文件保存到磁盘:<br><img src="/img/posts/apple/csr.png" alt="CSR文件"></p><p>最终生成如下所示的CSR文件，该文件将用于向苹果开发者后台请求cer证书:<br><img src="/img/posts/apple/csrfile.png" alt="CSR文件" style="width:120px"></p><h3 id="2-创建开发者证书"><a href="#2-创建开发者证书" class="headerlink" title="2. 创建开发者证书"></a>2. 创建开发者证书</h3><p>苹果开发者证书分为两种：开发版与发布版，对于仅需要开发测试的应用，可以申请开发版证书，而对于要打包并发布到苹果商城中的应用，则必须选择发布版证书，需要注意的是一个账号只能申请三张发布版的证书，证书的有限性意味着多个苹果应用可能共用一张发布证书。</p><p>进入苹果开发者证书管理后台，点击左侧Certificate选项，选择自己需要的证书类型(开发/发布)，如图所示:</p><p><img src="/img/posts/apple/certificate.png" alt="开发证书"></p><p>点击右上方”+”创建证书,由于发布证书已达三个数量上限，为了演示方便这里选择了开发版的证书创建:<br><img src="/img/posts/apple/certificate_1.png" alt="开发证书"></p><p>点击下一步，上传CSR文件，也就是上面我们在本地所创建的文件:<br><img src="/img/posts/apple/certificate_2.png" alt="开发证书"></p><p>上传完成后可获得开发者证书，下载该证书并双击添加到本地证书中:<br><img src="/img/posts/apple/certificate_3.png" alt="开发证书"></p><h3 id="3-创建App-ID"><a href="#3-创建App-ID" class="headerlink" title="3. 创建App ID"></a>3. 创建App ID</h3><p>在Apple Store中，每一个程序应用对应于一个App ID，所以在应用发布前需要在苹果的开发者后台创建一个App ID，流程如下：</p><p>进入苹果开发者证书管理后台，点击左侧App ID选项，如图所示:<br><img src="/img/posts/apple/appidview.png" alt="App ID界面预览"></p><p>点击右上角的“＋”，新建App ID，此处需要注意的就是Bundle ID必须填写完整的包名:<br><img src="/img/posts/apple/appid_create_1.png" alt="App ID界面预览"></p><p>由于我的应用拥有推送的功能，所以需要在下方为Push Notifications打勾:<br><img src="/img/posts/apple/appid_create_2.png" alt="App ID界面预览"></p><p>不断下一步之后可完成App ID的创建，由于刚刚激活了主动推送的功能，所以这里还需要完成配置的操作，在App ID列表中点击刚刚创建的App ID，可看到Push Notifications状态如下：<br><img src="/img/posts/apple/push_notification.png" alt="主动推送"></p><h3 id="4-激活主动推送功能"><a href="#4-激活主动推送功能" class="headerlink" title="4. 激活主动推送功能"></a>4. 激活主动推送功能</h3><p>点击“Edit”对主动推送功能进行激活，如下图所示:<br><img src="/img/posts/apple/push_notification_1.png" alt="主动推送"></p><p>点击”create Certificate”按钮，上传我们在第一步中所创建的CSR文件:<br><img src="/img/posts/apple/push_notification_2.png" alt="主动推送"></p><p>不断下一步以完成了推送功能的配置，这时候可将推送功能的证书notification_push.cer下载到本地，如下图：<br><img src="/img/posts/apple/push_notification_3.png" alt="主动推送"></p><p>双击程序，将证书安装添加至本地中：<br><img src="/img/posts/apple/push_notification_4.png" alt="主动推送" style="width:120px"></p><h3 id="5-导出p12文件"><a href="#5-导出p12文件" class="headerlink" title="5. 导出p12文件"></a>5. 导出p12文件</h3><p>每一个带密钥的证书都可以导出p12文件，这是一个加密的文件，只要知道其密码，就可以在其他设备上使用，在钥匙串访问中右键点击刚刚添加的主动推送证书，选择“导出…”<br><img src="/img/posts/apple/push_notification_5.png" alt="p12文件导出"></p><p>以p12格式进行文件导出:<br><img src="/img/posts/apple/push_notification_6.png" alt="p12文件导出"></p><p>输入p12的密码:<br><img src="/img/posts/apple/push_notification_7.png" alt="p12文件导出"></p><p>下面就是导出后的文件:<br><img src="/img/posts/apple/push_notification_8.png" alt="p12文件导出" style="width:120px"></p><h3 id="6-生成Provisioning-Profiles"><a href="#6-生成Provisioning-Profiles" class="headerlink" title="6. 生成Provisioning Profiles"></a>6. 生成Provisioning Profiles</h3><p>Provisioning Profiles，简称PP文件，该文件将appID，开发者证书，硬件Device绑定在一起，在开发者中心配置好后可以添加到Xcode上，也可以直接在Xcode上连接开发者中心生成，真机调试时需要在PP文件中添加真机的udid，由于此处配置的是发布版本的PP文件，所以没有了添加真机udid这一步骤。</p><p>点击开发者中心的Provisioning Profiles，选择Distribution，如下:<br><img src="/img/posts/apple/provision.png" alt="provisioning"></p><p>点击右上方”+”,选择自己需要的版本进行配置，由于要在商城发布，这里我选择的是App Store:<br><img src="/img/posts/apple/provision_1.png" alt="provisioning"></p><p>下一步选择需要配置的AppId:<br><img src="/img/posts/apple/provision_2.png" alt="provisioning"></p><p>下一步选择开发证书:<br><img src="/img/posts/apple/provision_3.png" alt="provisioning"></p><p>填写provision profile的名字，完成配置:<br><img src="/img/posts/apple/provision_4.png" alt="provisioning"></p><p>配置成功后下载PP文件,如下图:<br><img src="/img/posts/apple/provision_5.png" alt="provisioning"></p><p><img src="/img/posts/apple/provision_6.png" alt="provisioning" style="width:120px"></p><p>至此，苹果打包所需的所有证书已经准备完毕。</p><h3 id="6-Xcode打包生成ipa"><a href="#6-Xcode打包生成ipa" class="headerlink" title="6. Xcode打包生成ipa"></a>6. Xcode打包生成ipa</h3><p>前序的准备工作上面已经详细介绍，真是呕心沥血啊… 废话少说，直接进入主题</p><p>打开Xcode，选择需要打包的项目，然后执行 Product -&gt; Scheme -&gt; Edit Scheme<br><img src="/img/posts/apple/xcode.png" alt="xcode"></p><p>把Build Configuration改为Release，如下图:<br><img src="/img/posts/apple/xcode_2.png" alt="xcode"></p><p>完成上述操作后执行 Product -&gt; Archieve<br><img src="/img/posts/apple/xcode_3.png" alt="xcode"></p><p>选择导出的用途后点击export按钮:<br><img src="/img/posts/apple/xcode_4.png" alt="xcode"></p><p>在此过程会有一个签名自动验证的过程，此处略过许多坑…历经千辛，排除万难，终于打包成功:<br><img src="/img/posts/apple/xcode_5.png" alt="xcode" style="width:120px"></p><p>如果你认为，只要按上述步骤完成就可以成功打包，那真是天真了…在整个过程中可以会遇到许多的问题，这里就不一一描述了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;苹果的证书多样纷杂，且打包审核的过程严格复杂，各种身份验证，证书验证的操作相信已经把许多人搞晕，包括本人在内，最近一个项目需要打包上
      
    
    </summary>
    
      <category term="ios" scheme="https://boxizen.github.io/categories/ios/"/>
    
    
      <category term="证书 apple" scheme="https://boxizen.github.io/tags/%E8%AF%81%E4%B9%A6-apple/"/>
    
  </entry>
  
  <entry>
    <title>MUI -- 移动页面开发利器</title>
    <link href="https://boxizen.github.io/2015/05/03/mui/"/>
    <id>https://boxizen.github.io/2015/05/03/mui/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2018-07-09T12:03:32.008Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>HTML5在移动app/页面的开发上得到了越来越广泛的应用，今天向大家推荐一款移动app页面开发的框架–MUI，这是由DCloud推出的前端开发框架，通过该框架，我们可以利用HTML5更高效地打造出属于一款移动app或页面。</p></blockquote><h2 id="Amaze-UI"><a href="#Amaze-UI" class="headerlink" title="Amaze UI"></a>Amaze UI</h2><p>接触过移动页面开发的同学可能听说或者使用过一些框架，比如说最近正热的amaze ui,这是中国首个HTML5 跨屏前端框架，非常轻量小巧，但毕竟是一个兼容PC端与移动端的框架，对于移动端控件与性能方面的支持较为薄弱，对于专门针对移动app来说不是一个最优的选择。</p><h2 id="Sencha-Touch"><a href="#Sencha-Touch" class="headerlink" title="Sencha Touch"></a>Sencha Touch</h2><p>这时也许你会说sencha touch这个框架，这个确实是个专门针对移动app开发的前端框架，对移动端控件与性能等各个方面的支持都非常完备，但是该框架非常庞大，做移动app尚可接受，而如果是开发移动网页的话就有些过了，大家都知道手机是一寸流量一寸金啊，为了简单的几个页面而加载重量的框架就有点得不偿失了，而且该框架只能使用Ext.js作为开发语言，为此我也被该框架折腾过好长一段时间。</p><h2 id="MUI"><a href="#MUI" class="headerlink" title="MUI"></a>MUI</h2><p>针对上面两种框架，今天推荐的MUI可以说解决了上面所提出的一些问题：</p><ol><li><p>首先它是一个专门针对移动app/网页开发的前端框架，非常轻量级，压缩版的文件大小大概80k左右;</p></li><li><p>其次MUI提供了非常丰富的控件与布局使用，我们仅仅需要使用简单的几句代码就可以创建出非常漂亮的移动控件，而控件的自定义也是简单方便;</p></li><li><p>再者，DCloud团队为这款框架打出了”最接近原声APP体验的高性能前端框架”，可见在性能优化方面应该是做得不错的，至少在我的使用过程中确实体验良好;</p></li><li><p>最后要说的是，MUI并不限制js库的使用，你可以自由自主地选择自己熟悉的js库，比如说jquery，Ext.js，亦或者是zepto.js等等</p></li></ol><h2 id="应用效果"><a href="#应用效果" class="headerlink" title="应用效果"></a>应用效果</h2><p>下面是我用MUI框架做的一个移动端网页:</p><p><img src="/img/posts/front-end/clove-preg.jpg" alt="clovefemale" width="45%"></p><p>更多关于MUI的使用与介绍可点击:<a href="http://dcloudio.github.io/mui/" target="_blank" rel="noopener">http://dcloudio.github.io/mui/</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;HTML5在移动app/页面的开发上得到了越来越广泛的应用，今天向大家推荐一款移动app页面开发的框架–MUI，这是由DCloud推
      
    
    </summary>
    
      <category term="前端" scheme="https://boxizen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="移动app 移动页面" scheme="https://boxizen.github.io/tags/%E7%A7%BB%E5%8A%A8app-%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>SSH协议应用(二):隧道(端口转发)与内网穿透</title>
    <link href="https://boxizen.github.io/2015/04/24/ssh_simple_application/"/>
    <id>https://boxizen.github.io/2015/04/24/ssh_simple_application/</id>
    <published>2015-04-23T16:00:00.000Z</published>
    <updated>2018-07-01T02:59:02.797Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>距上一篇SSH文章的更新已有9个多月时间，首先深深地自惭一下，对自己的执行力表示自责。回到正题，在这篇文章中，本人将会总结介绍我认为SSH最具魅力的特性与应用 —— 隧道与端口转发。</p></blockquote><h3 id="一、SSH隧道"><a href="#一、SSH隧道" class="headerlink" title="一、SSH隧道"></a><strong>一、SSH隧道</strong></h3><h4 id="1-1-一个悲伤的故事"><a href="#1-1-一个悲伤的故事" class="headerlink" title="1.1 一个悲伤的故事"></a><strong>1.1 一个悲伤的故事</strong></h4><p>我还记得在上计算机网络课的时候，任课老师曾跟我们讲过这样一个故事：在一个遥远的年代，正值政治敏感时期，一位同学在寝室里查询法L功与反共的相关资料，几个小时后，他被警察叔叔带走了，剧终…</p><p>除了感叹天朝网管能力的彪悍，通过这件事件我们还可以得出，我们应该要坚信党的领导，拥护党的领导，任何质疑党，质疑社会主义行为都应该受到无情的封杀！</p><h4 id="1-2-应用背景"><a href="#1-2-应用背景" class="headerlink" title="1.2 应用背景"></a><strong>1.2 应用背景</strong></h4><p>咳咳，不过话说回来，假如今日再搜索“法L功”，“草L网”，“阿娇与阿希”，“宋ZY与江ZM”或是其他一些关键词，会得到如下提示：</p><p><img src="/img/posts/ssh/search.png" alt="搜索敏感提示"></p><p>对于这种情况，很多人都会使用VPN，这确实是种不错的解决方法，不过听说天朝也准备全面封杀VPN的代理上网方式，这时候，SSH的魅力体现出来了 - 隧道。</p><h4 id="1-3-使用条件"><a href="#1-3-使用条件" class="headerlink" title="1.3 使用条件"></a><strong>1.3 使用条件</strong></h4><p>首先，我们得有一台可以上外网的设备，本人拥有一台阿里云的香港节点服务器，由于该服务器身处大陆外，网络不受限制，可以自由地上Google与Youtube等国外网站。</p><p>假设A是我的PC机，B是阿里云服务器(此机器上已安装SSH服务)，C为在大陆被屏蔽的网站，通过B，我们可以在A与C之间建立一条隧道(tunneling)，也就是说我们可以在自己的PC机上间接地访问C网站。</p><h4 id="1-4-使用方法"><a href="#1-4-使用方法" class="headerlink" title="1.4 使用方法"></a><strong>1.4 使用方法</strong></h4><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 本地端口:远程主机:远程端口 远程用户名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh -L 7001:localhost:389 LdapServerHost</span><br></pre></td></tr></table></figure><p>参数:</p><ol><li>-f 后台认证用户密码，常与-N连用，不用登陆远程主机</li><li>-N 不执行脚本或命令，常与-f连用</li><li>-L 将本地端口转发到远程指定机器的指定端口</li><li>-R 将远程端口转发到本地机器的指定端口</li><li>-C 压缩数据</li></ol><h3 id="二、内网穿透"><a href="#二、内网穿透" class="headerlink" title="二、内网穿透"></a><strong>二、内网穿透</strong></h3><p>其实隧道与内网穿透都属于端口转发的范畴，所谓隧道其实是从本地机器出发，是一个由内向外的过程，而内网穿透则恰恰相反，是外网设备访问内网机器的一个过程。</p><h4 id="2-1-应用场景"><a href="#2-1-应用场景" class="headerlink" title="2.1 应用场景"></a><strong>2.1 应用场景</strong></h4><p>在微信公众平台的开发过程中，官方需要开发者提供自己的服务器以进行认证与测试，这就要求开发者需要将项目部署至服务器上才能进行测试，这对于开发者的调试造成了许多的麻烦，我们需要不断的更新服务器的代码以获得最新的测试效果，而SSH的内网穿透对于这种情况是一种很好的福利。通过内网穿透，我们就可以访问内网中用于开发的机器，这样就避免了频繁提交-更新的繁琐过程。</p><h4 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a><strong>2.2 使用方法</strong></h4><p>与在第一部分的本地端口转发格式相同，内网穿透使用-R参数</p><p>格式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 本地端口:远程主机:远程端口 远程用户名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh -R 7001:localhost:389 LdapServerHost</span><br></pre></td></tr></table></figure><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h3><p>前两个部分简单地介绍了SSH中隧道与内网穿透的相关内容，前面已经提到，SSH隧道与内网穿透实际上同属于端口转发的内容，而端口转发是有方向的，从SSH-Client向SSH-Server转发的过程我们叫做SSH隧道端口转发，而从SSH-Server向SSH-Client的过程我们则称作是内网穿透。</p><p>对于SSH隧道，我们可以通过它来翻墙上youtube、google等被屏蔽的国外网站，同样地，某些公司的防火墙屏蔽掉了一些站点，我们也可以利用SSH隧道技术来访问这些站点。</p><p>而对于内网穿透，本人更多的是因开发调试而用，这样就可以将内网的机器公开到外网中，即使没有公网IP，外围的设备仍然可以访问到这台机器，这对于校园网或是小区网络内的机器而言经常受用。</p><p>本篇文章讲述的SSH使用主要是针对Linux系统，对于Windows系统如果想要使用SSH服务，可以利用putty这款软件，有时间我会把Windows下使用SSH服务做一次总结与分享。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;距上一篇SSH文章的更新已有9个多月时间，首先深深地自惭一下，对自己的执行力表示自责。回到正题，在这篇文章中，本人将会总结介绍我认为
      
    
    </summary>
    
      <category term="网络" scheme="https://boxizen.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SSH协议 隧道 端口转发" scheme="https://boxizen.github.io/tags/SSH%E5%8D%8F%E8%AE%AE-%E9%9A%A7%E9%81%93-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>nginx web服务器初识</title>
    <link href="https://boxizen.github.io/2014/08/07/nginx/"/>
    <id>https://boxizen.github.io/2014/08/07/nginx/</id>
    <published>2014-08-06T16:00:00.000Z</published>
    <updated>2018-07-01T02:58:43.975Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>作为一款处理多并发且具备高性能的Web服务器, nginx被越来越多地应用到各种企业中.<br>而其反向代理、配置简单等特性也逐渐受到开发者们的青睐和尝试.</p><p>本文将简单地说明介绍nginx的作用与简单使用,以供参考.</p></blockquote><h3 id="一、nginx为何物"><a href="#一、nginx为何物" class="headerlink" title="一、nginx为何物"></a><strong>一、nginx为何物</strong></h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><p>nginx是一款轻量级的网页服务器、<strong>反向代理器</strong> 以及电子邮件代理服务器.因它的稳定性、丰富功能集和低系统资源消耗等而闻名.<br>说到Web服务器, 首先可能会想到两大巨头:apache和IIS, 但是由于nginx服务器的高性能、低消耗等特点,此两巨头的地位已逐渐被nginx所取代.</p><h4 id="1-2应用"><a href="#1-2应用" class="headerlink" title="1.2应用"></a>1.2应用</h4><p>在国内, 许多互联网公司已经使用了nginx作为前端服务器, 如豆瓣,新浪,京东等等, 其中淘宝使用的tengine, 是阿里团队对nginx进行改造产生的衍生品, 实际上也是nginx内核.</p><h4 id="1-3特点"><a href="#1-3特点" class="headerlink" title="1.3特点"></a>1.3特点</h4><p><strong>（1）跨平台：</strong>Nginx 可以在大多数 Unix like OS编译运行，而且也有Windows的移植版本；</p><p><strong>（2）配置异常简单：</strong>非常容易上手。配置风格跟程序开发一样，神一般的配置；</p><p><strong>（3）非阻塞、高并发连接：</strong>数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能够支撑5万并发连接，在实际生产环境中跑到2～3万并发连接数。（这得益于Nginx使用了最新的epoll模型）</p><h3 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a><strong>二、反向代理</strong></h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>反向代理(Reverse Proxy)指的是服务器从外部接受来自客户端的请求, 然后将请求转发到内部的服务器群中, 由内部的服务器群返回结果给请求客户端, 在外部表现为一个服务器, 因此称为代理服务器.</p><h4 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h4><p><strong>（1）保护网站安全：</strong>任何来自Internet的请求必须先经过代理服务器</p><p><strong>（2）通过配置缓存功能加速Web请求：</strong>通过缓存内部服务器群的静态资源, 提高外围客户端的访问速度</p><p><strong>（3）实现负载均衡：</strong>外部的请求通过代理服务器转发给内部服务器, 代理服务器能够通过配置辨识内部服务器有哪些是宕机的, 这样可以将请求转发给正常的服务器, 在这里代理服务器又充当了负载均衡的作用, 平衡集群中服务器的压力.</p><h3 id="三、基本配置"><a href="#三、基本配置" class="headerlink" title="三、基本配置"></a><strong>三、基本配置</strong></h3><p><img src="/img/posts/nginx/nginx-settings.png" alt="nginx配置"></p><p>上面所示的图为本机ubuntu环境下的nginx配置, 当nginx启动时监听的是80端口, 服务器域名为local.jingkao.net, 当访问<a href="http://local.jingkao.net/java2015-ab时" target="_blank" rel="noopener">http://local.jingkao.net/java2015-ab时</a>, nginx将会把请求转发到<a href="http://127.0.0.1:1777服务器中" target="_blank" rel="noopener">http://127.0.0.1:1777服务器中</a>, 同理, 当客户端访问<a href="http://local.jingkao.net/usermanager时" target="_blank" rel="noopener">http://local.jingkao.net/usermanager时</a>, 请求将转发至 <a href="http://127.0.0.1:9601" target="_blank" rel="noopener">http://127.0.0.1:9601</a> 中. 上述便是nginx的最基本配置.</p><p>###本节完.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;作为一款处理多并发且具备高性能的Web服务器, nginx被越来越多地应用到各种企业中.&lt;br&gt;而其反向代理、配置简单等特性也逐渐受
      
    
    </summary>
    
      <category term="服务器" scheme="https://boxizen.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx 运维" scheme="https://boxizen.github.io/tags/nginx-%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>SSH协议应用(一):远程登录</title>
    <link href="https://boxizen.github.io/2014/08/06/ssh_remote_login/"/>
    <id>https://boxizen.github.io/2014/08/06/ssh_remote_login/</id>
    <published>2014-08-05T16:00:00.000Z</published>
    <updated>2018-07-01T02:58:53.778Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>自从更换到Ubuntu的操作环境，越来越被Linux的魅力所吸引，其众多的快捷键，更好的稳定性以及更快的速度等极大地提高了开发效率，而作为Linux基本配置的SSH更是让我大开眼界，通过Linux的SSH工具，可以让我们完成许多不可思议的工作，下面我将总结一下使用SSH以来的一些小知识，内容浅显，不足以体现SSH的博大精深。</p></blockquote><h3 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a><strong>一、简单介绍</strong></h3><h4 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h4><p>在最早的时候，互联网的通信都是以明文进行传输，这种传输方式安全性极差，一旦传输内容被截获，内容就将暴露无遗。1xxx年，xxxx设计了SSH协议，将登陆信息进行了加密，很快地这种协议成为了互联网安全的一种解决方案，并得到了广泛的普及。</p><h4 id="1-2-定义"><a href="#1-2-定义" class="headerlink" title="1.2 定义"></a>1.2 定义</h4><p><em>SSH(Secure Shell)</em> 是一种网络协议，该协议可以将传输的数据进行加密，以保证数据在网络传输过程中的安全性。</p><h4 id="1-3-SSH工具"><a href="#1-3-SSH工具" class="headerlink" title="1.3 SSH工具"></a>1.3 SSH工具</h4><p>需要注意的是，SSH是一种协议，其存在了多种实现，在Ubuntu中默认配置的SSH工具为OpenSSH，而Windows下则PuTTY使用得更多。本文章以Linux下的OPenSSH为例展开总结。</p><h3 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a><strong>二、基本使用</strong></h3><h4 id="2-1-远程登陆"><a href="#2-1-远程登陆" class="headerlink" title="2.1 远程登陆"></a>2.1 远程登陆</h4><p>SSH最常用于远程登陆，如下，表示连接到用户名为boxiZen，远程ip地址为172.26.12.159的机器上 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh boxizen@172.26.12.159　//默认端口为22</span><br><span class="line">ssh 172.26.12.159   //若本地用户名与远程机器用户相同，则可以省略用户名</span><br></pre></td></tr></table></figure><h4 id="2-2-修改端口"><a href="#2-2-修改端口" class="headerlink" title="2.2 修改端口"></a>2.2 修改端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 12530 boxizen@172.26.12.159</span><br></pre></td></tr></table></figure><h4 id="2-3-口令登陆"><a href="#2-3-口令登陆" class="headerlink" title="2.3 口令登陆"></a>2.3 口令登陆</h4><p>当不做任何配置，输入上述命令时，会要求你输入密码，若密码正确则可以正常登陆了．<br>当远程的公钥被接收后，它会保存在文件$HOME/.ssh/known_hosts中</p><h4 id="2-４-登陆过程"><a href="#2-４-登陆过程" class="headerlink" title="2.４ 登陆过程"></a>2.４ 登陆过程</h4><ol><li>用户使用ssh命令请求连接远程服务器</li><li>服务器接收到来自用户的登陆请求，把自己的公钥发给用户</li><li>用户使用服务器的公钥将登陆密码加密后，再发给用户</li><li>服务器使用自己的私钥解析密码，若密码正确，则同意用户登陆．</li></ol><h3 id="三、公钥登陆"><a href="#三、公钥登陆" class="headerlink" title="三、公钥登陆"></a><strong>三、公钥登陆</strong></h3><p>使用口令登陆的缺点是，每次登陆到远程服务器都要输入密码，非常麻烦，而且容易受到”中间人”的攻击．所谓的中间人攻击是指，可能会有别的机器冒充真正的服务器，利用他们提供的公钥套取用户的信息．</p><p>所幸的是ssh还提供了<strong>公钥登陆</strong>的方式进行安全登陆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen //在客户端生成公钥</span><br></pre></td></tr></table></figure><p>执行了上述命令后，会在$HOME/.ssh目录下生成id_rsa.pub和id_rsa两个文件，其中前者为公钥，后者为私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id boxizen@172.26.12.159</span><br></pre></td></tr></table></figure><p>上述命令将公钥上传到远程主机上面，执行成功了，再也不需要输入密码即可实现登陆了．<br>用户的公钥会保存在服务器目录下的$HOME/.ssh/authorized_keys文件中</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;自从更换到Ubuntu的操作环境，越来越被Linux的魅力所吸引，其众多的快捷键，更好的稳定性以及更快的速度等极大地提高了开发效率，
      
    
    </summary>
    
      <category term="网络" scheme="https://boxizen.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SSH协议 远程登录" scheme="https://boxizen.github.io/tags/SSH%E5%8D%8F%E8%AE%AE-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的工作原理</title>
    <link href="https://boxizen.github.io/2013/11/20/hashmap/"/>
    <id>https://boxizen.github.io/2013/11/20/hashmap/</id>
    <published>2013-11-19T16:00:00.000Z</published>
    <updated>2018-07-01T02:58:10.409Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --><blockquote><p>HashMap是近些年来java面试中常问到的知识点，很多人(包括我在内)都知道HashMap的用法，也知道HashMap与HashTable之间的区别，但是却不知其所以然，于是乎，本人开始查阅相关资料，解读HashMap的实现源代码，打算一探究竟。</p></blockquote><h3 id="一、HashMap的基本了解"><a href="#一、HashMap的基本了解" class="headerlink" title="一、HashMap的基本了解"></a><strong>一、HashMap的基本了解</strong></h3><h4 id="1-1-基本定义"><a href="#1-1-基本定义" class="headerlink" title="1.1 基本定义"></a><strong>1.1 基本定义</strong></h4><p>根据源代码的描述可知，HashMap是基于哈希表的Map接口的实现，其包含了Map接口的所有映射操作，并且允许使用null键和null值。</p><h4 id="1-2-与HashTable的区别"><a href="#1-2-与HashTable的区别" class="headerlink" title="1.2 与HashTable的区别"></a><strong>1.2 与HashTable的区别</strong></h4><p>HashMap可以近似地看成是HashTable但是它是非线程安全的，并且允许使用null键和null值，而这些都与HashTable恰巧相反。</p><p>注:HashMap可以使用ConcurrentHashMap代替，ConcurrentHashMap是一个线程安全，更加快速的HashMap，欲了解ConcurrentHashMap，可点击<a href="http://www.blogjava.net/wuxufeng8080/articles/152238.html" target="_blank" rel="noopener">这里</a></p><h4 id="1-3-存储结构"><a href="#1-3-存储结构" class="headerlink" title="1.3 存储结构"></a><strong>1.3 存储结构</strong></h4><p>HashMap的存储结构其实就是哈希表的存储结构(由数组与链表结合组成，称为链表的数组)。如下图所示:<br><img src="/img/posts/java/hashmap.png" alt="hashmap存储结构"><br>如上图所示，HashMap中元素存储的形式是键-值对(key-value对,即Entry对)，所有具有相同hashcode值的键(key)所对应的entry对会被链接起来组成一条链表，而数组的作用则是存储链表中第一个结点的地址值。</p><h3 id="二、影响HashMap性能的因素"><a href="#二、影响HashMap性能的因素" class="headerlink" title="二、影响HashMap性能的因素"></a><strong>二、影响HashMap性能的因素</strong></h3><p>在HashMap中，还存在着两个概念，<em>桶(buckets)</em>和<em>加载因子(load factor)</em>。</p><p>桶(buckets):上图中的标有0、1、2、3、….、11所对应的数组空间就是一个个桶。</p><p>加载因子(load factor):是哈希表在其容量自动增加之前可以达到多满的一种尺度，默认值是0.75。</p><p>根据源代码中所述，影响HashMap性能有两个因素:哈希表中的初始化容量(桶的数量)和加载因子。当哈希表中条目数超过了当前容量与加载因子的乘积时，哈希表将会作出自我调整，将容量扩充为原来的两倍，并且重新将原有的元素重新映射到表中，这一过程成为rehash。看到这里，相必大家会发现rehash操作是会造成时间与空间的开销的，因此为什么初始化容量与加载因子会影响HashMap的性能也就可以理解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例1.添加键-值对的java源代码:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry</span><br><span class="line">&lt;K,V&gt;</span><br><span class="line">    e = table[bucketIndex];    <span class="comment">//找到元素要插入的桶 </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry</span><br><span class="line">    &lt;K,V&gt;</span><br><span class="line">        (hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)     <span class="comment">//threshold的值为当前容量*加载因子(0.75)</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);   <span class="comment">//将HashMap的容量扩充为当前容量的两倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例2.扩充HashMap实例容量源代码:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//重新定义新容量的Entry对</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//rehash操作，将旧表中的元素重新映射到新表中</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//新的临界值为新的容量*加载因子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、put-get方法实现原理"><a href="#三、put-get方法实现原理" class="headerlink" title="三、put/get方法实现原理"></a><strong>三、put/get方法实现原理</strong></h3><p><em>put操作:</em>HashMap在进行put操作的时候，会首先调用Key值中的hashCode()方法，用于获取对应的bucket的下标值以便存放数据。具体操作可以参照如下的java源代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table .length );</span><br><span class="line">    <span class="keyword">for</span> (Entry</span><br><span class="line">        &lt;K,V&gt;</span><br><span class="line">            e = table[i]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) &#123;</span><br><span class="line">           V oldValue = e. value;</span><br><span class="line">           e. value = value;</span><br><span class="line">           e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上述代码所示，HashMap通过key值的hashcode获得了对应的bucket存储空间的下标，然后进入bucket空间，通过链表遍历的方式逐个查询，看看链表中是否已经存在了这个key的键-值对，如果已经存在则用新值替换旧值，否则插入新的键-值对。看到这里，相信大家会发现，hashCode值相同的两个值可能是不同的两个对象，而当put进去的是另一个hashCode值相等的对象时，会发生冲突，而在HashMap中解决这种冲突的方法就是将hashCode值相同的key值所对应的key-value对串联成一条链表，请见上面的HashMap数据结构图。</p><p><em>get操作:</em>HashMap在进行get操作的时候，与put方法类似，会首先调用Key值中的hashCode()方法，用于获取对应的bucket的下标值，找到bucket的位置后，再通过key.equals()方法找到对应的键-值对，从而获得对应的value值。java源代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Entry</span><br><span class="line">            &lt;K,V&gt;</span><br><span class="line">                e = table[ indexFor(hash, table.length)];</span><br><span class="line">        e != <span class="keyword">null</span>;</span><br><span class="line">        e = e. next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e. value;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h3><p>HashMap是基于hashing原理对key-value对进行存储与获取。</p><p>当使用put()方法添加key-value对时，它会首先检查hashCode的值，并以此获得对应的bucket位置进行存储，当发生冲突时(hashcode值相同的两个不同key)，新的key-value对会以结点的形式添加到链表的末尾。</p><p>而使用get()方法时，同样地会根据key的hashCode值找到相应的bucket位置，再通过key.equals()方法找到对应的key-value对，最终成功获取value值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 15 2018 14:44:13 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;HashMap是近些年来java面试中常问到的知识点，很多人(包括我在内)都知道HashMap的用法，也知道HashMap与Hash
      
    
    </summary>
    
      <category term="Java" scheme="https://boxizen.github.io/categories/Java/"/>
    
    
      <category term="HashMap" scheme="https://boxizen.github.io/tags/HashMap/"/>
    
  </entry>
  
</feed>
