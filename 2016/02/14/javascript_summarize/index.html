<!-- build time:Tue Jul 17 2018 10:10:54 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="boxi"><meta name="google-site-verification" content="iOm73y6vS5qme_s6tWGOVE1l5iATBiNi7Ye7J4dv68g"><meta name="baidu-site-verification" content="9BXA7j00i6"><title>JavaScript知识梳理 · boxi's box</title><meta name="description" content="本文梳理了JavaScript常见语言特性，以此巩固和加深自己对知识的理解。一、作用域和内存管理作用域&amp;amp;&amp;amp;作用域链每一个执行环境都有一个与之关联的变量对象，环境中定义的变量和函数都保存在这个对象中。全局函数无法查看局部函数的内部细节，但是局部函数却可以访问上层的执行环境，直至全局执行"><meta name="keywords" content="技术积累, 生活感悟"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/img/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/img/logo@2x.png" style="width:150px"><h3><a href="/">boxi's box</a></h3><div class="description"><p>Poor Guy In Shenzhen</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2263667870"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/boxi.zeng"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/boxizen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me">CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben </a><span>Edit by</span><a href="https://github.com/boxizen"> Boxi</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/photos">咔嚓</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JavaScript知识梳理</a></h3></div><div class="post-content"><blockquote><p>本文梳理了JavaScript常见语言特性，以此巩固和加深自己对知识的理解。</p></blockquote><h2 id="一、作用域和内存管理"><a href="#一、作用域和内存管理" class="headerlink" title="一、作用域和内存管理"></a>一、作用域和内存管理</h2><h3 id="作用域-amp-amp-作用域链"><a href="#作用域-amp-amp-作用域链" class="headerlink" title="作用域&amp;&amp;作用域链"></a><strong>作用域&amp;&amp;作用域链</strong></h3><p>每一个<strong>执行环境</strong>都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个对象中。</p><p>全局函数无法查看局部函数的内部细节，但是局部函数却可以访问上层的执行环境，直至全局执行环境，当需要在局部函数中访问某一属性或方法的时候，如果在当前的变量对象中找不到，就会在上层作用域中查找，直至全局函数，这种组织形式就是<strong>作用域链</strong>。</p><h3 id="垃圾收集策略"><a href="#垃圾收集策略" class="headerlink" title="垃圾收集策略"></a>垃圾收集策略</h3><p>JavaScript是一门具有自动垃圾回收机制的编程语言，开发人员不必关心内存的分配和回收问题。对于垃圾回收机制的原理很简单，就是找出那些不再继续使用的变量，然后释放其占用的内存即可。</p><p><strong>(1) 标记清除</strong></p><p>JavaScript中最常用的垃圾收集方式为标记清除，当变量进入环境(如在函数中声明一个变量)时，将此变量标记为”进入环境”，而当其离开环境时(函数执行完毕)，则将其标记为”离开环境”。</p><p>标记的方法可以通过翻转某个特殊位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。</p><p><strong>(2) 引用计数</strong></p><p>另一种不太常见的垃圾收集策略叫做引用计数，其含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，相反，如果包含这个引用的变量又取了另外一个值，则这个值的引用次数减1，当这个值引用次数变成0时，则说明无法再访问这个值了，因而其占用的内存空间会被回收。</p><p>这种策略有一个致命的缺点在于，当存在两个变量相互引用时，他们的引用次数将永远不为0，因而其占用的内存永远不会被释放。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><p>闭包是指有权访问另一函数作用域中变量和对象的函数，一般表现为函数内部的函数。</p><p>使用闭包的优点如下:</p><p><strong>(1) 延长作用域链</strong></p><p>由于闭包可以访问外部函数中的变量和对象，因此可达到延长作用域链的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> out = <span class="string">'外部变量'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 模仿块级作用域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">if</span>(now.getMonth() == <span class="number">0</span> &amp;&amp; now.getDate() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Happy new year'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>该做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链了。</p><p>当然闭包也存在着不足之处, 具体如下:</p><ul><li><p>(1) 增加了内存消耗。</p></li><li><p>(2) IE浏览器由于垃圾回收机制问题，有内存溢出的风险。</p></li><li><p>(3) 增加了代码的复杂度，不容易维护或调试。</p></li></ul><h2 id="二、面向对象编程"><a href="#二、面向对象编程" class="headerlink" title="二、面向对象编程"></a>二、面向对象编程</h2><h3 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型&amp;&amp;原型链"></a><strong>原型&amp;&amp;原型链</strong></h3><p>在JavaScript中，我们创建的所有函数都含有一个<strong>prototype</strong>的属性，这个属性是一个指针，指向一个对象，这个对象就是<strong>原型对象</strong>。原型对象作用是让该函数派生出来的所有实例均能共享其属性和方法。（<em>注:实例中有<strong><strong>proto</strong></strong>属性，该属性指向原型对象，而原型对象中的constuctor属性泽指向原来的函数。</em>）</p><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例斗包含一个指向原型对象的内部指针(<strong>proto</strong>)。假如让原型对象等于另一个类型的实例，则它将包含一个指向另一个原型对象的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，上述关系依然成立，如此层层递进，就构成了实例和原型的链条，也就是<strong>原型链 </strong>。</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a><strong>对象创建</strong></h3><p><strong>(1) 工厂模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br></pre></td></tr></table></figure><p>不足: 无法判断对象的类别。</p><p><strong>(2) 构造函数模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>, <span class="number">26</span>, <span class="string">'teacher'</span>);</span><br></pre></td></tr></table></figure><p>不足: 主要问题在于，构造函数中的方法需要在每一个实例上重新创建一遍，造成内存资源的浪费。</p><p><strong>(3) 原型模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 重新给prototype赋值，同时constuctor重新指向原来的构造函数</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'boxizen',</span><br><span class="line">  age: 24,</span><br><span class="line">  job: 'student',</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br></pre></td></tr></table></figure><p>不足: 原型模式的主要缺点在于对于引用型的属性来说，由于其被所有的实例对象共享，所以其中一个实例对象修改了引用型属性就会导致所有实例对象引用的属性发生改变，而这违反了面向对象中封装特性。</p><p><strong>(4) 组合使用构造函数模式和原型模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelly'</span>, <span class="string">'pt'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'boxizen'</span>, <span class="number">24</span>, <span class="string">'student'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'zhangsan'</span>, <span class="number">26</span>, <span class="string">'teacher'</span>);</span><br></pre></td></tr></table></figure><p>这是当前在ECMAScript中使用最广泛、认可度最高的一种创建自定义类型的方法。</p><h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>继承是面向对象语言中一个最为津津乐道的概念，许多OO语言对支持两种方式的继承：接口继承和实现继承，其中接口继承只继承方法签名，而实现继承则继承实际的方法。由于ECMAScript中没有方法签名，所以只支持实现继承，在ECMAScript中通过<strong>原型链(参考前面)</strong>来实现继承的。</p><p><strong>(1) 原型继承</strong></p><p>ECMAScript中将原型链作为实现继承的主要方法。其主要思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型方法</span></span><br><span class="line">SuperType.prototype.getSuperValue = funtion() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类原型指向父类实例</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 子类原型方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类实例</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSUperValue());</span><br></pre></td></tr></table></figure><p>不足: 原型继承最大的问题来自于包含引用类型值的原型。前面提到了包含引用类型值的属性会被所有实例共享，所以为什么属性在构造函数中定义，而不是在原型对象中定义的原因；在通过原型实现继承的时候，实例属性变成了原型属性，所以造成了包含引用类型的属性被所有实例继承的现象。</p><p><strong>(2) 借用构造函数</strong></p><p>借用构造函数实现继承的思路很简单，就是在子类构造函数中调用超类型构造函数，以实现继承超类型属性方法的目的，解决了原型继承中所带来引用类型的问题。而这一过程主要依靠<strong>call</strong>或<strong>apply</strong>来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SUperType</span></span><br><span class="line">  SUperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'yellow'</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SUbType();</span><br><span class="line">instance2.colors.push(<span class="string">'purple'</span>);</span><br></pre></td></tr></table></figure><p>不足: 借用构造继承的问题还是在于，前面所说的，方法都在构造函数中定义，因此函数复用无从谈起，同时也对内存资源造成了浪费。</p><p><strong>(3) 组合继承</strong></p><p>组合继承是将原型继承与借用构造继承结合在一起，避免两者的缺陷，发挥两者所长的一种继承模式，是JavaScript中最常用的继承模式。其主要思路是通过在子类构造函数调用超类构造函数，以实现对实例属性的继承，而通过原型链实现对原型属性和方法的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超类定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SuType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、BOM和客户端检测"><a href="#三、BOM和客户端检测" class="headerlink" title="三、BOM和客户端检测"></a>三、BOM和客户端检测</h2><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><strong>BOM</strong></h3><p><strong>(1) location对象</strong></p><p>location饰最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能，它既是window对象的属性，也是document对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|   属性名    |  例子      |   说明   |</span><br><span class="line">| :-----------: | :-----------:  |  :-----------:  |</span><br><span class="line">| hash |  #contents  | 返回URL的hash|</span><br><span class="line">| host |  www.wrox.com:<span class="number">80</span>  | 返回服务器名和端口号(如果有)|</span><br><span class="line">| hostname |  www.wrox.com  | 返回不带端口号的服务器名|</span><br><span class="line">| port |  <span class="number">80</span> | 返回端口号|</span><br><span class="line">| href |  http:<span class="comment">//www.wrox.com  | 返回完成URL，与location.toString()返回值一样|</span></span><br><span class="line">| pathname |  <span class="regexp">/boxizen/</span>  | URL中目录或文件名|</span><br><span class="line">| protocol |  http:  | 返回URI的协议|</span><br><span class="line">| search |  ?q=javascript  | 返回查询字符串|</span><br></pre></td></tr></table></figure><p><strong>(2) navigator对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|   属性名    |  说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| appName|  完整浏览器版本  |</span><br><span class="line">| userAgent|  浏览器的用户代理字符串  |</span><br><span class="line">| vendor|  浏览器品牌  |</span><br><span class="line">| language|  浏览器主语言  |</span><br><span class="line">| plugins|  浏览器安装的插件信息的数组  |</span><br><span class="line">| ...|  ...  |</span><br></pre></td></tr></table></figure><h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a><strong>检测插件</strong></h3><p>检测插件(IE无效):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> name = name.toLowerCase();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测IE中的插件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) history对象</strong></p><p>history对象保存着用户上网的历史记录，从窗口被打开那一刻起算起。</p><p>后退一页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>);</span><br><span class="line">history.back();</span><br></pre></td></tr></table></figure><p>前进一页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">1</span>);</span><br><span class="line">history.forward();</span><br></pre></td></tr></table></figure><p>跳转到历史记录中的某个页面，如果历史记录不包含该字符串，则该方法什么也不做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="string">'wrox.com'</span>);</span><br></pre></td></tr></table></figure><h3 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a><strong>客户端检测</strong></h3><p><strong>(1) 能力检测</strong></p><p>最常用也是最被广泛接受的客户端检测形式，通过判断浏览器的能力来识别浏览器的范围。</p><p><strong>(2) 怪癖检测</strong></p><p>通过识别浏览器的特殊行为判断特定的浏览器。而通常这些特殊行为表现为浏览器的BUG，譬如在IE8及更早的版本中存在一个BUG，即如果某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么改实例属性将不会出现在for-in循环中。</p><p><strong>(3) 用户代理检测</strong></p><p>在客户端，用户代理检测被看作是万不得已才用的做法，优先级排在能力检测和怪癖检测之后，原因在于浏览器经常使用<strong>电子欺骗</strong>的手段(在用户代理字符串中加入一些错误或误导性信息)欺骗服务器，以达到站点正确访问的目的。</p><p>用户代理检测的做法是通过<strong>navigator.userAgent</strong>属性得到代理字符串的值，再通过给该值做正则匹配以达到识别客户端浏览器的目的。</p><h2 id="四、DOM及其拓展"><a href="#四、DOM及其拓展" class="headerlink" title="四、DOM及其拓展"></a>四、DOM及其拓展</h2><p>DOM(文档对象模型)是针对HTML和XML文档的一个API，它描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p><h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a><strong>节点层次</strong></h3><p><strong>(1) Node类型</strong></p><p>DOM1级定义了一个Node接口，JavaScript中的所有节点类型都继承于该类型，因此所有节点类型都共享着相同的基本属性和方法，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法名    | 说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| **childNodes** |   获取第一个子节点|</span><br><span class="line">| parentNode |  获取父节点|</span><br><span class="line">| previousSibling |  获取上一个兄弟节点|</span><br><span class="line">| nextSibling |  获取下一个兄弟节点|</span><br><span class="line">| hasChildNodes() | 返回是否包含子节点|</span><br><span class="line">| appendChild() |  在最后插入子节点|</span><br><span class="line">| replaceChild() | 代替子节点|</span><br><span class="line">| removeChild() |  删除子节点|</span><br><span class="line">| insertBefore() | 在特定节点前面插入|</span><br></pre></td></tr></table></figure><p><strong>(2) Document类型</strong></p><p>JavaScript通过Document类型表示文档，Document节点nodeType为<strong>9</strong>, nodeName为<strong>#document</strong>，常见的属性及方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法名    | 说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| body |  指向&lt;body&gt;元素|</span><br><span class="line">| doctype |  指向&lt;!DOCTYPE&gt;元素|</span><br><span class="line">| title |  文档标题|</span><br><span class="line">| url |  文档所在的完整url |</span><br><span class="line">| referer |  来源页面的URL|</span><br><span class="line">| getElementById() |  取得id对应的元素|</span><br><span class="line">| getElementsByTagName() |  取得某个标签的元素集合|</span><br></pre></td></tr></table></figure><p><strong>(3) Element类型</strong></p><p>Element类型是Web编程中最常用的类型之一，因为它提供了对元素标签名、子节点及特性的访问，它的nodeType为<strong>1</strong>, nodeName为<strong>元素的标签名</strong>。</p><ul><li>HTML元素</li></ul><p>所有HTML元素都由HTMLElement类型表示，HTML元素继承于Element并添加了一些默认属性，因此可以直接访问这些属性，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.id);</span><br><span class="line"><span class="built_in">console</span>.log(div.className);</span><br><span class="line"><span class="built_in">console</span>.log(div.title);</span><br><span class="line"><span class="built_in">console</span>.log(div.lang);</span><br><span class="line"><span class="built_in">console</span>.log(div.dir);</span><br></pre></td></tr></table></figure><ul><li>取得属性</li></ul><p>在使用自定义属性的时候，可以通过getAttribute()方法取得该属性的值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-custom'</span>));</span><br></pre></td></tr></table></figure><ul><li>设置属性</li></ul><p>与getAttribute()相对应:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(<span class="string">'data-custom'</span>, <span class="string">'hehe'</span>);</span><br></pre></td></tr></table></figure><ul><li>attributes属性</li></ul><p>常用方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法名    | 说明   |</span><br><span class="line">| :-----------: | :-----------:  |</span><br><span class="line">| getNamedItem(name) |  获得nodeName为name的节点|</span><br><span class="line">| removeNamedItem(name) |  从属性列表移除nodeName为name的节点|</span><br><span class="line">| setNamedItem(name) |  添加节点，并以nodeName作为索引|</span><br><span class="line">| item(pos) |  返回位于数字pos位置处的节点|</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">'id'</span>).nodeValue;</span><br><span class="line"> element.attributes[i].nodeName;</span><br><span class="line"> element.attributes[i].nodeValue;</span><br></pre></td></tr></table></figure><ul><li>创建元素</li></ul><p>使用document.createElement()创建新的元素:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">div.id = <span class="string">'myDiv'</span>;</span><br><span class="line">div.className = <span class="string">'box'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><p><strong>(4) Text类型</strong></p><p>文本节点由Text表示，它的nodeType为<strong>3</strong>, nodeName为<strong>#text</strong>, 创建方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.className = <span class="string">'msg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;hello&lt;/stong&gt;"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.append(element);</span><br></pre></td></tr></table></figure><p><strong>(5) Attr类型</strong></p><p>元素属性在DOM中以Attr类型表示，它的nodeType为<strong>2</strong>，nodeName是<strong>属性的名称</strong>创建方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">'align'</span>);</span><br><span class="line">attr.value = <span class="string">'left'</span>;</span><br><span class="line"></span><br><span class="line">element.setAttribute(attr);</span><br><span class="line">element.getAttribute(<span class="string">'align'</span>);</span><br><span class="line">element.attributes[<span class="string">'align'</span>].nodeValue;</span><br></pre></td></tr></table></figure><p><strong>(6) DocumentFragment类型</strong></p><p>在所有的节点类型中，只有DocumentFragment在文档中没有对应的标记。DOM规定DocumentFragment是一种“轻量级文档”，可以包含和控制节点，但却不会像完整的文档那样占用额外的资源。nodeType为<strong>11</strong>, nodeName为<strong>#document-fragment</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"> li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + (i+<span class="number">1</span>)));</span><br><span class="line"> fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>由此也可以看出，使用DocumentFragment可以减少因频繁插入dom元素而带来的资源消耗，减少了dom结构的重排次数，从而得到了更高效的性能提升。</p><p><strong>(7) 其它类型</strong></p><p>其它类型还包括<strong>Comment类型</strong>、<strong>CDATASelection</strong>和<strong>DocumentType类型</strong>，因使用频率较低，故不做总结。</p><h3 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a><strong>DOM操作技术</strong></h3><p><strong>(1) 动态脚本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"> script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">  script.appendChild(<span class="built_in">document</span>.createTextNode(code));</span><br><span class="line"> &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">  script.text = code;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 动态样式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">css</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line"> style.type = <span class="string">'text/css'</span>;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">  style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line"> &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">  style.styleSheet.cssText = css;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 操作表格</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line">table.border = <span class="number">1</span>;</span><br><span class="line">table.width = <span class="string">'100%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'cell 1,1'</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'cell 2,1'</span>));</span><br></pre></td></tr></table></figure><h3 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a><strong>DOM扩展</strong></h3><p>尽管DOM作为API意境非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩展。对DOM的主要两个扩展是<strong>Selectors API</strong>和<strong>HTML5</strong>。</p><p><strong>(1) Selectors API</strong></p><p>Selectors API是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS查询。所有实现这一功能的JavaScript库都会写一个基础的CSS解析器，然后再使用已有的DOM方法查询文档并找到匹配的节点。而把这个功能变成原生API后，解析和树查询操作可以在浏览器内部通过编译后的代码完成，极大地改善了性能。</p><ul><li><strong>querySelector()方法</strong></li></ul><p>接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDIV = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>querySelectorAll()方法</strong></li></ul><p>与querySelector()一样，不过返回的是一个NodeList的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).querySelectorAll(<span class="string">'em'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>matchesSelector()方法</strong></li></ul><p>这个地方接收一个参数，即CSS选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.body.matchesSelector(<span class="string">'body.page1'</span>)) &#123;</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) HTML5</strong></p><ul><li><strong>与类相关的扩充</strong></li></ul><p>getElementsByClassName()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得所有类中包含'username'和'current'的元素，类名先后顺序无所谓</span></span><br><span class="line"><span class="keyword">var</span> name =  <span class="built_in">document</span>.getElementsByClassName(<span class="string">'username current'</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>焦点管理</strong></li></ul><p>H5中添加了DOM焦点的功能，包括<strong>document.activeElement</strong>和<strong>hasFocus()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">button.focus();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>HTMLDocument的变化</strong></li></ul><p>H5把<strong>readyState</strong>、<strong>compatMode</strong>和<strong>head</strong>属性添加进标准:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档加载进度</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line"> <span class="comment">// 文档加载完毕</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染页面模式</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line"> <span class="comment">// 标准模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文档头部</span></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>插入标记</strong></li></ul><p><strong>innerHTML</strong>和<strong>outerHTML</strong>属性，避免了插入元素时频繁创建节点以及处理节点间关系的繁琐步骤，带来了极大的便利，但是需要谨慎其带来的性能消耗问题。</p><ul><li><strong>其它</strong></li></ul><p>此外H5还添加了字符集属性、自定义属性和scrollIntoView()等dom相关的属性及方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符集</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.charset); <span class="comment">//UTF-16</span></span><br><span class="line"><span class="built_in">document</span>.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据属性</span></span><br><span class="line">&lt;div id=<span class="string">'myDiv'</span> data-appId=<span class="string">'1234'</span> data-myName=<span class="string">'boxizen'</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="comment">// 取得自定义属性值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId;</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myName;</span><br><span class="line"><span class="comment">// 设置自定义属性值</span></span><br><span class="line">div.dataset.appId = <span class="string">'12345566'</span>;</span><br><span class="line">div.dataset.myName = <span class="string">'boxi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让元素可见</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView();</span><br></pre></td></tr></table></figure><h2 id="五、事件机制"><a href="#五、事件机制" class="headerlink" title="五、事件机制"></a>五、事件机制</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a><strong>事件流</strong></h3><p>事件流指的是从页面中接收事件的顺序，在IE和Netscape开发团队中提出了差不多完全相反的事件流的概念，其中IE的事件流是<strong>事件冒泡流</strong>, 而Netscape的事件流是<strong>事件捕获流</strong>。</p><p><strong>(1) 事件冒泡</strong></p><p>IE的事件流称为<strong>事件冒泡</strong>，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点(文档)。事件接收的顺序如下(以点击页面中某一div为例):</p><p><img src="/img/posts/js_summary/bubble.png" alt="事件冒泡"></p><p><strong>(2) 事件捕获</strong></p><p>Netscape Communicator团队提出的另一种事件流叫<strong>事件捕获</strong>，它的思想是不太具体的节点应该更早接收到事件，而具体的节点应该最后接收到事件，它的用意在于在事件到达预定目标之前捕获它。事件接收顺序如下:</p><p><img src="/img/posts/js_summary/catch.png" alt="事件捕获"></p><p><strong>(3) DOM事件流</strong></p><p>“DOM2级事件”规定的事件流包括三个阶段: 事件捕获阶段、处于目标阶段和事件冒泡阶段。仍以前面简单的HTML页面为例，单击div元素会按照下图所示的顺序触发事件:</p><p><img src="/img/posts/js_summary/event-w3c.png" alt="DOM事件流"></p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a><strong>事件处理程序</strong></h3><p>事件是用户或浏览器自身执行的某个动作，而响应某个事件的函数就叫做<strong>事件处理程序(或事件侦听)</strong>。</p><p><strong>(1) HTML事件处理程序</strong></p><p>在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其它地方定义的脚本:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;input type="button" value='Click Me' onclick='showMsg()'&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式有两个缺点，首先是存在<strong>时差问题</strong>, 用户可能会在元素一出现在页面就触发响应的事件，但当时的事件处理程序可能不具备执行条件。另一个缺点是HTML与JavaScript代码<strong>紧密耦合</strong>, 造成维护的困难。</p><p><strong>(2) DOM0级事件处理程序</strong></p><p>通过JavaScript指定事件处理程序就是把一个方法赋值给一个元素的事件处理程序属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">'Click Me'</span> id=<span class="string">'btn'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>如此处理，事件处理程序在元素的作用域下运行，this就是当前元素，还有一个好处，可以直接给onclick属性赋值为null删除事件处理程序。</p><p><strong>(3) DOM2级事件处理程序</strong></p><p>DOM2级事件处理程序定义了两个方法用于处理指定和删除事件处理程序的操作: <strong>addEventListener</strong>和<strong>removeEventListener</strong>。<br>它们都接收三个参数: 时间类型、事件处理方法和一个布尔值(true表示在事件捕获阶段调用事件处理程序，默认为false)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">'Click Me'</span> id=<span class="string">'btn'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> <span class="comment">// 添加第一个事件监听</span></span><br><span class="line"> btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click it!'</span>);</span><br><span class="line"> &#125;, <span class="literal">true</span>);		</span><br><span class="line"> <span class="comment">// 添加第二个事件监听</span></span><br><span class="line"> <span class="keyword">var</span> clickEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hehehe'</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> btn.addEventListener(<span class="string">'click'</span>, clickEvent, <span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 删除第二个监听事件</span></span><br><span class="line"> btn.removeEventListenr(<span class="string">'click'</span>, clickEvent, <span class="literal">true</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这么做有的好处是可以为一个元素添加<strong>多个事件监听</strong>。</p><p>IE不支持addEventListener和removeEventListener两个方法，但是它却实现了类似的两个方法<strong>attachEvent</strong>和<strong>detachEvent</strong>，由于IE8及其更早的版本只支持事件冒泡，所以通过attachEvent添加的事件处理程序都会被添加到冒泡阶段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">'Click Me'</span> id=<span class="string">'btn'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 添加事件监听</span></span><br><span class="line"> btn.attachEvent(<span class="string">'onclick'</span>, handler);</span><br><span class="line"> <span class="comment">// 删除监听事件</span></span><br><span class="line"> btn.detachEvent(<span class="string">'onclick'</span>, handler);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，与DOM0的事件处理程序不同的是，DOM0事件处理程序会在其所属元素的作用域内运行，而在使用attachEvent()情况下，事件处理程序会在全局作用域内运行。并且在使用attachEvent()为某元素添加多个事件的时候，当事件触发时，会以添加事件时<strong>相反的</strong>顺序执行事件处理程序，这一点是跟DOM1事件处理不同的。</p><p><strong>(4) 跨浏览器事件处理程序</strong></p><p>根据上述事件处理程序的特点，可以写出如下兼容各个浏览器的事件处理程序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"> addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line">   element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent) &#123;</span><br><span class="line">   element.attachEvent(<span class="string">'on'</span>+type, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   element.[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,		</span><br><span class="line"> removeHandler: fuction(element, type, handler) &#123;</span><br><span class="line">  <span class="keyword">if</span>(element.removeListener) &#123;</span><br><span class="line">   element.removeListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent) &#123;</span><br><span class="line">   element.detach(<span class="string">'on'</span> + type, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">  &#125;	</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><strong>事件对象</strong></h3><p><strong>(1) DOM事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法    | 类型   | 读/写 | 说明 |</span><br><span class="line">| :-----------: | :-----------:  | :-----------:  | :-----------:  |</span><br><span class="line">| bubbles| <span class="built_in">Boolean</span>| 只读| 表明事件是否冒泡 |</span><br><span class="line">| cancelable| <span class="built_in">Boolean</span>| 只读| 表明是否可以取消事件的默认行为 |</span><br><span class="line">| currentTarget| Element| 只读| 其事件处理程序当前正在处理事件的那个元素 |</span><br><span class="line">| detail| Integer| 只读| 与事件相关的细节信息 |</span><br><span class="line">| eventPhase| Integer| 只读| 调用事件处理程序的阶段:<span class="number">1</span>捕获,<span class="number">2</span>:目标,<span class="number">3</span>:冒泡 |</span><br><span class="line">| preventDefault()| <span class="built_in">Function</span>| 只读| 取消默认行为，如果cancelable为<span class="literal">true</span>，则可调用该方法 |</span><br><span class="line">| stopPropagation()| <span class="built_in">Function</span>| 只读| 取消事件的进一步捕获或冒泡，如果bubles为<span class="literal">true</span>，则可调用该方法 |</span><br><span class="line">| target| Element| 只读| 事件的目标 |</span><br><span class="line">| type| <span class="built_in">String</span>| 只读| 被触发的事件类型 |</span><br><span class="line">| ... | ... | ... | ... |</span><br></pre></td></tr></table></figure><p><strong>(2) IE中的事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|   属性/方法    | 类型   | 读/写 | 说明 |</span><br><span class="line">| :-----------: | :-----------:  | :-----------:  | :-----------:  |</span><br><span class="line">| cancelBubble| <span class="built_in">Boolean</span>| 读/写| 默认为<span class="literal">false</span>，但将其设置为<span class="literal">true</span>就可以取消事件冒泡,同**stopPropagation()** |</span><br><span class="line">| returnValue| <span class="built_in">Boolean</span>| 读/写| 默认为<span class="literal">true</span>，但将其设置为<span class="literal">false</span>就可以取消默认行为,同**preventDefault()** |</span><br><span class="line">| srcElement| Element| 只读| 事件的目标,同**target** |</span><br><span class="line">| type | <span class="built_in">String</span>| 只读| 被触发的事件类型 |</span><br></pre></td></tr></table></figure><p><strong>(3) 跨浏览器的事件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"> addHandler: funcrion(element, type, handler) &#123;</span><br><span class="line">  <span class="comment">// 参见上一部分</span></span><br><span class="line"> &#125;, </span><br><span class="line"> removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参见上一部分</span></span><br><span class="line"> &#125;,</span><br><span class="line"> getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line"> &#125;,</span><br><span class="line"> getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line"> &#125;,</span><br><span class="line"> preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(event.preventDefault) &#123;</span><br><span class="line"></span><br><span class="line">   event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(event.stopPropagation) &#123;</span><br><span class="line">   event.stopPropagation();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a><strong>事件类型</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|   事件    | 类型   | 说明 |</span><br><span class="line">| :-----------: | :-----------:  | :-----------:  |</span><br><span class="line">| load | UI | 页面完全加载触发(包括图像、js、css等外部资源)|</span><br><span class="line">| unload | UI | 文档被卸载后触发(用户从一个页面切换到另一个)|</span><br><span class="line">| resize | UI | 浏览器窗口大小调整触发|</span><br><span class="line">| scroll | UI | 滚动条滚动时触发，作用在windows对象上|</span><br><span class="line">| focus | 焦点 | 元素获得焦点时触发|</span><br><span class="line">| unfocus | 焦点 | 元素失去焦点时触发|</span><br><span class="line">| click | 鼠标 | 点击时触发|</span><br><span class="line">| dblclick | 鼠标 | 双击时触发|</span><br><span class="line">| mousedown | 鼠标 | 按下鼠标时触发|</span><br><span class="line">| mouseup | 鼠标 | 释放鼠标时触发|</span><br><span class="line">| mouseenter | 鼠标 | 鼠标移到特定元素时触发|</span><br><span class="line">| mouseleave | 鼠标 | 鼠标离开特定元素时触发|</span><br><span class="line">| mousemove | 鼠标 | 移动鼠标时时触发|</span><br><span class="line">| mousewheel | 滚轮 | 滚动滚轮时触发|</span><br><span class="line">| keydown | 键盘 | 用户按下键盘上任意键时触发，返回键盘的代码|</span><br><span class="line">| keyup | 键盘 | 用户释放键盘上任意键时触发|</span><br><span class="line">| keypress | 键盘 | 用户按下键盘上任意键时触发，返回ASCII字符|</span><br><span class="line">| hashchange | HTML5 | hash值改变时触发|</span><br><span class="line">| orientationchange | 设备 | safari查看模式旋转时触发|</span><br><span class="line">| deviceorientation | 设备 | 设备方向变化时触发|</span><br><span class="line">| devicemotion | 设备 | 设备移动时时触发|</span><br></pre></td></tr></table></figure><h3 id="事件代理和委托"><a href="#事件代理和委托" class="headerlink" title="事件代理和委托"></a><strong>事件代理和委托</strong></h3><p>在JavaScript中，添加到页面上事件的数量直接影响页面的整体运行性能，导致这一问题原因主要是，每一个<strong>函数都是对象</strong>，都会占用内存，内存中对象越多，性能就越差。</p><p>对“事件处理程序过多”问题的解决方案就是<strong>事件委托</strong>，它利用了<strong>事件冒泡</strong>，达到了只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><p>如给某一列表下所以选项添加事件可以这么写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'myLinks'</span>);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(list, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> event = EventUtil.getEvent(event);</span><br><span class="line"> <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'dosomething'</span>:</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'gosomewhere'</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'go somewhere'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">'sayhi'</span>:</span><br><span class="line">     	 <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">     	 <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用事件委托/代理的优点主要有:</p><ul><li><p>可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件，从而提升页面的整体运行性能。</p></li><li><p>可以实现新增子对象时的动态事件绑定，不需要再给新增的元素单独添加事件。</p></li></ul><h3 id="事件模拟"><a href="#事件模拟" class="headerlink" title="事件模拟"></a><strong>事件模拟</strong></h3><p><strong>(1) DOM中的事件模拟</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line"><span class="comment">// 初始化事件对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p><strong>(2) IE中的事件模拟</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">'myTextBox'</span>);</span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEventObject();</span><br><span class="line"><span class="comment">// 初始化事件对象</span></span><br><span class="line">event.altKey = <span class="literal">false</span>;</span><br><span class="line">event.ctrlKey = <span class="literal">false</span>;</span><br><span class="line">event.shiftKey = <span class="literal">false</span>;</span><br><span class="line">event.keyCode = <span class="number">65</span>;</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.fireEvent(<span class="string">'onkeypress'</span>, event);</span><br></pre></td></tr></table></figure><h2 id="六、错误处理机制"><a href="#六、错误处理机制" class="headerlink" title="六、错误处理机制"></a>六、错误处理机制</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h3><p>由于JavaScript本身是动态语言，且多年来一直没有固定的开发工具，因此人们普遍认为它是一种最难调试的编程语言，抛出的错误没有上下文信息，让人摸不着头脑，而在ECMAScript3中引入了一套错误处理机制，意在帮助开发者更好地处理错误，更好地避免错误的发生。</p><p>ECMA-262定义了如下7种错误:</p><ul><li><p>Error, 基类型，其他错误类型都继承自该类型。</p></li><li><p>EvalError, 在使用eval()函数时发生异常时抛出。</p></li><li><p>RangeError, 数值超出相应范围时触发。</p></li><li><p>ReferenceError, 在找不到对象的情况下抛出。</p></li><li><p>SyntaxError, 语法错误时抛出。</p></li><li><p>TypeError, 在执行特定类型操作的时候，变量类型不符合要求时抛出。</p></li><li><p>URIError, URI格式错误时抛出。</p></li></ul><p><strong>(1) try-catch语句</strong></p><p>JavaScript中处理错误标准的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> someFunction();</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line"> <span class="keyword">if</span>(error <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理类型错误</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(error <span class="keyword">instanceof</span> <span class="built_in">ReferenceError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理引用错误</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 其他类型错误</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) throw语句</strong></p><p>与try-catch语句相配，用于随时抛出自定义错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">'CustomError'</span>;</span><br><span class="line"> <span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">'my massage'</span>);</span><br></pre></td></tr></table></figure><p><strong>(3) 错误(error)事件</strong></p><p>任何没有通过try-catch处理的错误都会触发window对象的error事件，onerror事件处理程序不会创建event对象，但它接收三个参数: <strong>错误消息</strong>、<strong>错误所在URL</strong>和<strong>错误行号</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line</span>) </span>&#123;</span><br><span class="line"> alert(message);</span><br><span class="line"> <span class="comment">// 阻止浏览器默认行为</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) 错误记录到服务器</strong></p><p>开发Web应用程序过程中一种常见的做法，就是集中保存错误日志，以便找重要错误的原因。而在复杂的程序员，通过把前端JavaScript错误集中汇报给后端也显得同样重要，常见的做法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params">sev, msg</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"> img.src = <span class="string">'log.php?sev='</span> + <span class="built_in">encodeURIComponent</span>(sev) + <span class="string">'&amp;msg='</span> + <span class="built_in">encodeURIComponent</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">// 可能出错的操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line"> logError(<span class="string">'nonfatal'</span>, ex.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Image发送请求的好处有:</p><ul><li><p>所有浏览器都支持Image对象，包括那些不支持XMLHttpRequest对象的浏览器</p></li><li><p>可以避免跨域限制。</p></li><li><p>在记录错误过程中出问题的概率比较低。</p></li></ul><h3 id="错误调试"><a href="#错误调试" class="headerlink" title="错误调试"></a><strong>错误调试</strong></h3><p><strong>(1) 控制台输出</strong></p><p>主要手段是通过console.log将信息输出至控制台中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">console</span> == <span class="string">'object'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> opera == <span class="string">'object'</span>) &#123;</span><br><span class="line">  opera.postError(message);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure><p><strong>(2) 页面输出</strong></p><p>在页面上直接输出错误信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="built_in">console</span> = <span class="built_in">document</span>.getElementById(<span class="string">'debuginfo'</span>);</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">console</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span> = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line">  <span class="built_in">console</span>.id = <span class="string">'debuginfo'</span>;</span><br><span class="line">  <span class="built_in">console</span>.style.border = <span class="string">'1px solid #000'</span>;</span><br><span class="line">  .....</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(<span class="built_in">console</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.innerHTML += <span class="string">'&lt;p&gt;'</span> + message + <span class="string">'&lt;/p&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 错误抛出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">condition, message</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(!condition) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(<span class="keyword">typeof</span> num1 == <span class="string">'number'</span> &amp;&amp; obj1 <span class="keyword">instanceof</span> <span class="built_in">Number</span>, <span class="string">'类型错误'</span>);</span><br></pre></td></tr></table></figure><h2 id="七、JSON和AJAX"><a href="#七、JSON和AJAX" class="headerlink" title="七、JSON和AJAX"></a>七、JSON和AJAX</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><strong>JSON</strong></h3><p>曾经有一段时间，XML是互联网上传输结构化数据的事实标准，然而业界一直不乏质疑XML的声音，他们认为XML结构臃肿，操作繁琐，而JSON的出现，让这些开发者看到了更加轻量、操作便捷的数据交换格式，并开始广泛使用这种结构化数据，渐渐地，JSON已经取代了XML，成为时下在互联网上最流行的数据传输格式。</p><p><strong>(1) 语法</strong></p><p>JSON支持<strong>简单值</strong>、<strong>对象</strong>和<strong>数组</strong>三种类型的值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单值</span></span><br><span class="line"><span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"name"</span>: <span class="string">"boxizen"</span>,</span><br><span class="line"> <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">[</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"boxizen"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Lisi"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">42</span></span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>需要注意的是，JSON对象中属性名必须加上双引号。</p><p><strong>(2) 解析与序列化</strong></p><p>JSON对象有两个方法: <strong>stringify()</strong>和<strong>parse()</strong>, 这两个方法分别用于<strong>把JavaScript对象序列化为JSON字符串</strong>和<strong>把JSON字符串解析为JavaScript对象</strong>。</p><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h3><p>Ajax的技术核心是<strong>XMLHttpRequest</strong>，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现</p><p><strong>(1) XMLHttpRequest基本用法</strong></p><p><strong>XHR创建:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> xhr;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">  <span class="keyword">var</span> activexName = [ <span class="string">"MSXML2.XMLHTTP"</span>, <span class="string">"Microsoft.XMLHTTP"</span> ]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; activexName.length; i++) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(activexName[i]);</span><br><span class="line">    <span class="keyword">if</span>(xhr) &#123;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get请求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> req = createXHR();</span><br><span class="line"> <span class="keyword">if</span>(req) &#123;</span><br><span class="line">  req.open(<span class="string">"GET"</span>, <span class="string">"http://xxxxx"</span>, <span class="literal">true</span>);</span><br><span class="line">  req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 0未初始化，1启动，2发送，3接收部分数据，4接收到全部响应数据</span></span><br><span class="line">   <span class="keyword">if</span>(req.readState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.status == <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(req.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     alert(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  req.send(<span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>post请求:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> req = createXHR();</span><br><span class="line"> <span class="keyword">if</span>(req) &#123;			</span><br><span class="line">  req.open(<span class="string">'POST'</span>, <span class="string">'http://xxxx'</span>, <span class="literal">true</span>);</span><br><span class="line">  req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(req.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(req.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     alert(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  req.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">  req.send(serialize(form));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) XMLHttpRequest扩展</strong></p><p>鉴于XMLHttpRequest已经得到广泛使用，成为了事实标准，W3C也着手制定相应标准以规范其行为，XHR1级把已有的XHR对象的实现细节描述了出来，而XHR2级将继续拓展功能。</p><p><strong>FormData</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'boxizen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接传入表单元素</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">....</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://xxxx'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><p>使用FormData的方便之处在于不必明确地在XHR对象上设置请求头部，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong></p><p>IE8为XHR对象添加了timeout属性，表示请求在等待响应多少毫秒后就停止，同时会触发ontimeout事件，而此功能后来也被收入了XHR2级规范中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">....</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://xxxx'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 超时时间设为1秒</span></span><br><span class="line">xhr.timeout = <span class="number">1000</span>;</span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><h3 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a><strong>跨域资源共享</strong></h3><p>通过Ajax通信的一个主要限制，来自于跨域安全策略(同源策略)，即XHR对象只能访问同源(相同的协议、相同的域名和相同的端口)下的资源。这种安全策略从一定程度上可以防止恶意行为的出现，但是合理的跨域请求在某些开发场景下却显得格外重要。</p><p>为了解决<strong>跨域资源</strong>访问问题，W3C提出了<strong>CORS</strong>的工作草案, 即Cross-Origin Resource Sharing，它的基本思想是通过自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是应该成功还是失败的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发送Origin的请求头</span></span><br><span class="line">Origin: http:<span class="comment">//bignews.boxizen.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器通过Access-Control-Allow-Origin请求判断该请求是否被允许, </span></span><br><span class="line"><span class="comment">// 如果回应与Origin值相同的或者是"*"的值，则表示该请求被允许</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//bignews.boxizen.com/</span></span><br></pre></td></tr></table></figure><p><strong>(1) IE对CORS的实现</strong></p><p>IE为实现跨域请求，引入了<strong>XDR</strong>对象，即XDomainRequest, 它与XHR不同之处在于:</p><ul><li>cookie不会随请求发送，也不会随响应返回</li><li>只能设置头部信息中的Content-Type字段</li><li>不能访问响应的头部信息</li><li>只支持get/post方法</li></ul><p>具体实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(xdr.responseText);</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'errors!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与XHR不同的是，XDR的open方法只接收两个参数</span></span><br><span class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://bignews.boxizen.com/ajax/'</span>);</span><br><span class="line">xdr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>(2) 其他浏览器对CORS的实现</strong></p><p>其他的浏览器通过对XHR对象实现了跨域的支持，不过出现了一些限制：</p><ul><li>不能通过setRequestHeader()设置自定义头部</li><li>不能发送和接收cookie</li><li>调用getAllRequestHeaders()总会返回空字符串</li></ul><p><strong>(3) 跨浏览器的CORS</strong></p><p>每个浏览器对CORS的支持程度都不一样，但是所有的浏览器都支持简单的(不带自定义头部信息和凭据的)请求，因此有必要实现一套跨浏览器方案的跨域请求。通过判断XHR中是否包含<strong>“withCredentials”</strong>属性来判断是否支持CORS跨域。</p><p>创建跨浏览器的CORS请求对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method, url</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> <span class="keyword">if</span>(<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) &#123;</span><br><span class="line">  xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.XDomainRequest) &#123;</span><br><span class="line">  vxhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">  vxhr.open(method, url);</span><br><span class="line">  xhr = vxhr</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xhr = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送CORS请求:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">'get'</span>, <span class="string">'http://bignews.boxizen.com/ajax'</span>);</span><br><span class="line"><span class="keyword">if</span>(request) &#123;</span><br><span class="line"> request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line"> &#125;</span><br><span class="line"> request.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a><strong>其他跨域技术</strong></h3><p><strong>(1) 图像Ping</strong></p><p>我们知道，一个网页可以加载任何网页中的图像资源，利用这一点可以实现简单的跨域方式，这也是在线广告跟踪浏览量的主要方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'done!'</span>);		</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'http://bignews.boxizen.com/statistics'</span>;</span><br></pre></td></tr></table></figure><p>这种方式有两种主要缺点:</p><ul><li>只能发送Get请求</li><li>不能获得服务器端响应的文本信息</li></ul><p><strong>(2) JSONP</strong></p><p>它由两部分组成：<strong>回调函数</strong>和<strong>json数据</strong>，格式看起来是这样的:</p><p><strong>callback({“name”: “boxizen”})</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleReponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'name:'</span> + response.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://bignews.boxizen.com/jsonp'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure><p>使用JSONP一个最大的优点是可以访问服务器端的响应，支持浏览器端和服务器端的双向通信。而它的缺点也是显而易见的:</p><ul><li>JSONP是从其他域中加载代码执行，如果其他域不安全，可能会在响应中夹带一些恶意代码，因此在使用不是你自己运维的web服务时，一定要保证它安全可靠</li><li>确定JSONP请求是否失败并不容易。</li></ul><h2 id="八、客户端存储"><a href="#八、客户端存储" class="headerlink" title="八、客户端存储"></a>八、客户端存储</h2><h3 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a><strong>离线检测</strong></h3><p>HTML5中定义了一个<strong>navigator.onLine</strong>属性，用于监测设备是否处理在线状态，为<strong>true</strong>即在线，为<strong>false</strong>即离线。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(navigator.onLine) &#123;</span><br><span class="line"> <span class="comment">// 正常工作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 执行离线状态时的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，HTML5还定义了两个事件:<strong>online</strong>和<strong>offline</strong>，当网络从离线变为在线或者从在线变为离线时分别触发这两个事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'online'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'online'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'offline'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>判断应用是否在线一般的做法是，在页面加载后，先通过navigator.onLine取得初始的状态，然后再通过上述两个事件确定网络的变化状态。</p><h3 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a><strong>应用缓存</strong></h3><p>HTML5的应用缓存(application cache),简称为appcache，是专门为开发离线Web应用设计的，是从浏览器缓存中分出来的一块缓存区。想使用这个缓存保存数据，可以使用一个<strong>描述文件(manifest file)</strong>，列出要下载和缓存的资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#Comment</span><br><span class="line"></span><br><span class="line">file.js</span><br><span class="line">file.css</span><br></pre></td></tr></table></figure><p>然后再将描述文件域页面关联起来，可以在</p><html>中的manifest属性中指定这个文件的路径，这个文件的MIME类型必须是<strong>text/cache-manifest</strong>:<p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=<span class="string">"/offline.manifest"</span>&gt;</span><br></pre></td></tr></table></figure><p>此外JavaScript中还提供了<strong>applicationCache</strong>的对象对离线资源进行操作和管理，此处略去。</p><h3 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a><strong>客户端存储</strong></h3><p>随着WebApp的出现，产生了对能够直接在客户端上存储用户信息能力的要求。</p><p><strong>(1) Cookie</strong></p><p>Cookie最初是在客户端存储会话信息的。</p><p><strong>(2) IE用户数据</strong></p><p><strong>(3) Web存储机制</strong></p><ul><li><p>sessionStorage对象</p></li><li><p>globalStorage对象</p></li><li><p>localStorage对象</p></li></ul><p><strong>(4) IndexedDB</strong></p></html></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-02-14</span><i class="fa fa-tag"></i><a class="tag" href="/categories/前端/" title="前端">前端 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript</a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://boxizen.github.io/2016/02/14/javascript_summarize/,boxi's box,JavaScript知识梳理,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2016/04/05/effective_javascript/" title="编写高质量JavaScript代码">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/12/25/http_protocol/" title="图解HTTP 学习笔记">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine=new Valine({el:"#vcomments",notify:!0,verify:!1,app_id:"bUTfY8SwOBitSS8uqiV0vG0I-gzGzoHsz",app_key:"N6bRxFzuVXEBBdX96fGb1i4e",placeholder:"来，一起快活",path:window.location.pathname,avatar:"monsterid"})</script></div></div></div></div><script src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1274080808'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s13.cnzz.com/z_stat.php%3Fid%3D1274080808%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">var ifm=document.getElementById("iframe");ifm&&($(window).width()>500?ifm.height=document.documentElement.clientHeight-250||400:ifm.height=200)</script></body></html><!-- rebuild by neat -->