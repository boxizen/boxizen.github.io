<!-- build time:Sun Jul 01 2018 18:30:38 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="boxi"><title>Electron 构建跨平台桌面应用 · boxi's box</title><meta name="description" content="简介Electron 是一款可以通过 Web前端技术 构建跨平台桌面应用的框架。其原名为 Atom Shell， 是 Github 社区原本为 Atom 编辑器设计的一个跨平台应用外壳，它将 Chromium 和 Node.js 的事件循环整合在一起，并提供了一些与原生系统交互的 API。简单地说，"><meta name="keywords" content="技术积累, 生活感悟"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/img/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/img/logo@2x.png" style="width:150px"><h3><a href="/">boxi's box</a></h3><div class="description"><p>Poor Guy In Shenzhen</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2263667870"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/boxi.zeng"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/boxizen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me">CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben </a><span>Edit by</span><a href="https://github.com/boxizen"> Boxi</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/photo">咔嚓</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Electron 构建跨平台桌面应用</a></h3></div><div class="post-content"><p><img src="/img/posts/electron/electron.jpeg" alt="electron apps"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Electron 是一款可以通过 Web前端技术 构建跨平台桌面应用的框架。其原名为 Atom Shell， 是 Github 社区原本为 Atom 编辑器设计的一个跨平台应用外壳，它将 Chromium 和 Node.js 的事件循环整合在一起，并提供了一些与原生系统交互的 API。</p><p>简单地说，通过 Electron，我们可以使用自己所熟悉的前端技术轻松构建出一款能运行在Windows, Linux 和 Mac 上的桌面级应用程序。</p><p>现阶段已有许多优秀的桌面应用都是基于 Electron 开发，其中如 Atom 编辑器，VS Code 和 Postman 等等都是我们所熟知的，下面列出这当中的部分应用，是不是看到了许多熟悉的图标呢？</p><p><img src="/img/posts/electron/electron_apps.jpeg" alt="electron apps"></p><h1 id="Electron-和-NW-js"><a href="#Electron-和-NW-js" class="headerlink" title="Electron 和 NW.js"></a>Electron 和 NW.js</h1><p>其实使用 Web前端技术 构建桌面应用早已不是什么新鲜事，在业界里诸如 NW.js，Brackets-Shell 和 HEX 框架也可以做同样的事情，而在 Electron 出现之前，NW.js 的发展势头最为猛烈。</p><h2 id="从-node-webkit-到-Atom-Shell"><a href="#从-node-webkit-到-Atom-Shell" class="headerlink" title="从 node-webkit 到 Atom Shell"></a>从 node-webkit 到 Atom Shell</h2><p>相信前端开发者对 NW.js 并不陌生，它的前身又叫 node-webkit，同样是一种跨平台桌面应用的开发框架。而说起 NW.js 和 Electron 之间的一段渊源可能却鲜有人知道：</p><p>node-webkit 项目最先由 Intel 公司的 <a href="https://github.com/rogerwang" target="_blank" rel="noopener">王文睿</a> 发起，由于公司投入的资源较少，前期的主要开发和维护工作主要由实习生 <a href="https://github.com/zcbenz" target="_blank" rel="noopener">赵成</a> 完成。据该实习生后来的描述，在 node-webkit 项目引起越来越多人的关注与使用后，自己失去了对该项目的完全自主权，恰逢 Github 此时在寻找一种利用 HTML 和 Node.js 开发桌面应用的方式，这成为了他转战 Github，投入到 Atom Shell 开发的重要原因。</p><p>下图为 NW.js 前期的提交贡献记录(左边是赵成，右边为王文睿)：</p><p><img src="/img/posts/electron/nw_commit.png" alt="node-webkit commits"></p><h2 id="主要差异"><a href="#主要差异" class="headerlink" title="主要差异"></a>主要差异</h2><p>针对与 NW.js 的主要差异，Electron 官方给出了如下四个方面：</p><p><em>1. 应用的入口</em></p><p>与 NW.js 不同的是，Electron 采用一个 JavaScript 脚本作为入口程序(NW.js 使用 HTML 文件作为入口)，并在该脚本中创建和维护窗体的生命周期，这种做法更加贴近传统 Node.js 的写法，与 Chrome Packaged App 的做法一致，为程序开发能够带来一定灵活性。</p><p><em>构建系统</em></p><p>为避免构建整个 Chromium 带来的复杂度，Electron 通过一个独立的共享库 libchromiumcontent 来访问 Chromium 的 Content API。</p><p><em>Node集成</em></p><p>在 NW.js 中，Node 的集成需要在 Chromium 中打补丁来实现，而Electron 则通过各个平台的消息循环与 libuv 的循环集成，避免了直接在 Chromium 上做改动。</p><p><em>多上下文</em></p><p>NW.js 里面包含了 node context 和 web context，而在 Electron 中仅有一个 context，这得益于 Node.js 的多上下文特性。</p><p>当然，Electron 优于 NW.js 的地方不仅仅只有上面所描述的几点，更丰富的文档资料，更活跃的社区，更及时的更新以及更多成熟应用的诞生使 electron 得到了越来越多人的推崇与贡献。</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="案例运行"><a href="#案例运行" class="headerlink" title="案例运行"></a>案例运行</h2><p>使用下面三步即可构建最简单的 Hello World 桌面程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 克隆官方的例子</span><br><span class="line">$ git clone https:<span class="comment">//github.com/electron/electron-quick-start</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 进入项目目录</span><br><span class="line">$ cd electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 安装项目依赖后执行该程序</span><br><span class="line">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>运行效果如下:</p><p><img src="/img/posts/electron/hello_world.jpeg" alt="hello world"></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>察看目录结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .gitignore	</span><br><span class="line">├── index.html</span><br><span class="line">├── LICENSE.md</span><br><span class="line">├── main.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── renderer.js</span><br></pre></td></tr></table></figure><p>主要分为三个部分:</p><ul><li>package.json: 定义了项目的依赖以及程序的主入口文件 main.js。</li><li>main.js: 负责创建应用窗口，并赋予其与当前操作系统的原生GUI交互的功能。</li><li>index.html: 定义了页面的渲染内容，即 “Hello World” 字符串。</li></ul><p>Electron 程序启动时，会产生两条进程，分别是主进程和渲染进程，main.js 脚本执行的环境就是主进程，负责管理和维护着渲染进程的生命周期，拥有绝大部分 node模块 的调用能力；而在 main.js 中创建的每一个窗体则对应着一个渲染进程，它们之间相互独立，且都具备部分 Node模块 的功能。</p><p>主进程与渲染进程的关系如下图所示，它们之间通过 IPC 模块进行消息交互，关于 IPC 模块的使用，下面会提到。</p><p><img src="/img/posts/electron/atom-shell-structure.png" alt="structure"></p><h1 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h1><p>这个部分将介绍 Electron 里面常用到的几个功能模块。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>上面提到，Electron 中包含了主进程和渲染进程，事实上主进程就是一个后台进程，掌控着渲染进程的创建与销毁动作，且官方提供的绝大部分模块也只能在该进程中调用。</p><p>主进程与渲染进程之间的通信通过 IPC(进程间通信)模块完成，IPC模块可划分为 ipcMain 和 ipcRenderer 两个部分，其中 ipcMain 对应 主进程中的 IPC模块，而 ipcRenderer 则是在渲染进程中使用，下面直接看个例子:</p><p>main.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 ipcMain 模块</span></span><br><span class="line"><span class="keyword">const</span> ipcMain = <span class="built_in">require</span>(<span class="string">'electron'</span>).ipcMain;</span><br><span class="line"><span class="comment">// 监听 ‘blabla’ 通道，收到消息后输出，并向 'blibli' 通道发送消息</span></span><br><span class="line">ipcMain.on(<span class="string">'blabla'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">  event.sender.send(<span class="string">'blibli'</span>, <span class="string">'hello client!'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 ipcRenderer 模块</span></span><br><span class="line"><span class="keyword">const</span> ipcRenderer = <span class="built_in">require</span>(<span class="string">'electron'</span>).ipcRenderer;  </span><br><span class="line"><span class="comment">// 向 'blabla' 通道发送消息</span></span><br><span class="line">ipcRenderer.send(<span class="string">'blabla'</span>, <span class="string">'hello server!'</span>);</span><br><span class="line"><span class="comment">// 监听 ‘blibli’ 通道, 收到消息后输出</span></span><br><span class="line">ipcRenderer.on(<span class="string">'blibli'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event,arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出效果正如你所期望那样:</p><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello server!</span><br></pre></td></tr></table></figure><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello client!</span><br></pre></td></tr></table></figure><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>上面提到了大部分模块只能在主进程中调用，为了突破这种限制，Electron 官方还提供了 remote 模块以简化进程间的通讯。</p><p>通过 remote 模块，渲染进程可以方便地引用主进程中的模块和全局变量等。</p><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global.person = &#123;</span><br><span class="line">  name: <span class="string">'boxizen'</span>,</span><br><span class="line">  sex : <span class="string">'male'</span>,</span><br><span class="line">  age : <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用 remote 模块</span></span><br><span class="line"><span class="keyword">const</span> remote = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote;</span><br><span class="line"><span class="comment">// 输出 main.js 中定义的 person 全局对象的 age 属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(remote.getGlobal(<span class="string">'person'</span>).age);</span><br></pre></td></tr></table></figure><p>输出效果(index.html):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><h2 id="lt-webview"><a href="#lt-webview" class="headerlink" title="&lt;webview>"></a>&lt;webview></h2><p>&lt;webview> 是个比较有趣的标签，可以将线上的页面嵌入进 Electron app 中，与 iframe 不同的是，webview 和应用运行的是不同的进程，不拥有渲染进程的权限。</p><p>下面将演示如何将微信网页版嵌入进 Electron 应用里，只需要简单的两步：</p><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;webview autosize=<span class="string">"on"</span> src=<span class="string">"https://wx.qq.com/"</span> style=<span class="string">"display:inline-flex; width:1000px; height:764px"</span>&gt;&lt;/webview&gt;</span><br></pre></td></tr></table></figure><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">1000</span>, <span class="attr">height</span>: <span class="number">764</span>, <span class="attr">resizable</span>: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/img/posts/electron/wechat.jpg" alt="wechat"></p><p>这样一个PC版的微信就大功告成了，实际上就是把利用 webview 标签加载微信网页版的在线地址，再在main.js中调整窗体大小以适配网页版的微信，是不是很简单呢。</p><p>webview 对象中包含 <strong>insertCSS()</strong> 和 <strong>executeJavaScript()</strong> 两个方法，表示可以插入样式代码和执行 js 脚本，这样我们就可以对加载页面中的样式及交互逻辑进行修改。默认的 webview 没有 node 功能，而如果设置了 nodeintegration 属性，它将整合node，拥有可以使用系统底层的资源。</p><p>此外 webview 中的 <strong>preload</strong> 属性允许在页面的脚本执行前预加载一个指定的脚本，下面我们利用该属性和 <strong>executeJavaScript()</strong> 方法实现 electron 版微信的未读消息角标展示。</p><p>index.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这里使用 preload 属性预加载了 badge.js 脚本 --&gt;</span><br><span class="line">&lt;webview id=<span class="string">"foo"</span> autosize=<span class="string">"on"</span> preload=<span class="string">"badge.js"</span> src=<span class="string">"https://wx.qq.com/"</span> style=<span class="string">"display:inline-flex; width:1000px; height:764px"</span>&gt;&lt;/webview&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> webview = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>);      </span><br><span class="line">  webview.addEventListener(<span class="string">'dom-ready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;             </span><br><span class="line">  webview.executeJavaScript(<span class="string">'badge.get()'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>badge.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 IPC 模块</span></span><br><span class="line"><span class="keyword">const</span> ipcRenderer = <span class="built_in">require</span>(<span class="string">'electron'</span>).ipcRenderer;</span><br><span class="line"></span><br><span class="line">badge = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  	<span class="comment">// 监听微信左侧面板节点变化</span></span><br><span class="line">    $(<span class="string">".panel"</span>).bind(<span class="string">'DOMSubtreeModified'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;	      </span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">0</span>;	   </span><br><span class="line">      <span class="comment">// 累加所有未读消息   </span></span><br><span class="line">      $(<span class="string">".icon.web_wechat_reddot_middle"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        count += <span class="built_in">parseInt</span>(<span class="keyword">this</span>.textContent);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 通过 IPC 发送给主进程</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipcRenderer.send(<span class="string">'badge-changed'</span>, count.toString());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ipcRenderer.send(<span class="string">'badge-changed'</span>, <span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"><span class="keyword">const</span> ipcMain = electron.ipcMain;</span><br><span class="line"><span class="keyword">const</span> app = electron.app</span><br><span class="line"></span><br><span class="line">exports.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听角标通道消息</span></span><br><span class="line">  ipcMain.on(<span class="string">'badge-changed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, num</span>) </span>&#123;</span><br><span class="line">    app.dock.setBadge(num);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下，可以发现 Electron 的 dock 角标显示的未读消息数(11)跟微信中面板中未读消息数量一致:</p><p><img src="/img/posts/electron/dock.jpg" alt="wechat"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然 Electron 中还有许多实用的模块，如作为桌面中必不可少的 <strong>Menu</strong> 和 <strong>Tray</strong> 模块、拥有调用当前操作系统功能的 <strong>Shell</strong> 模块、NW.js 中不具备的自动更新功能 - <strong>autoUpdater</strong> 模块、自动提交奔溃报告的 <strong>crashReporter</strong> 模块和全局快捷键模块 <strong>global-shortcut</strong> 等等，此处不做过多介绍。</p><h1 id="打包构建"><a href="#打包构建" class="headerlink" title="打包构建"></a>打包构建</h1><p>Electron 打包的方式有很多种，常见的有 electron-builder、electron-packager 和 asar几种，在这里我使用的是 electron-packager 作为应用的打包工具。</p><p>首先还是得先安装 electron-packager:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install electron-packager --save-dev</span><br></pre></td></tr></table></figure><p>然后在 package.json 中编写构建命令，下面生成了分别在 Windows 和 Mac 下的两条构建命令:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"> <span class="string">"start"</span>: <span class="string">"electron ."</span>,</span><br><span class="line"> <span class="string">"build-win"</span>: <span class="string">"electron-packager . doubanFM --platform=win32 --arch=x64 --version=1.2.6 --icon=./fm.ico --overwrite --ignore=node_modules/electron-*"</span>,</span><br><span class="line"> <span class="string">"build-mac"</span>: <span class="string">"electron-packager . doubanFM --platform=darwin --arch=x64 --version=1.2.6 --icon=./fm.icns --overwrite"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行构建命令, done!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build-mac</span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-09-11</span><i class="fa fa-tag"></i><a class="tag" href="/categories/前端/" title="前端">前端 </a><a class="tag" href="/tags/electron-跨平台/" title="electron 跨平台">electron 跨平台</a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2016/09/11/electron/,boxi's box,Electron 构建跨平台桌面应用,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/08/22/vue_erp/" title="Vue 浅析与实践">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/04/05/effective_javascript/" title="编写高质量JavaScript代码">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine=new Valine({el:"#vcomments",notify:!0,verify:!1,app_id:"bUTfY8SwOBitSS8uqiV0vG0I-gzGzoHsz",app_key:"N6bRxFzuVXEBBdX96fGb1i4e",placeholder:"来，一起快活",path:window.location.pathname,avatar:"monsterid"})</script></div></div></div></div><script src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1274080808'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s13.cnzz.com/z_stat.php%3Fid%3D1274080808%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">var ifm=document.getElementById("iframe");ifm&&($(window).width()>500?ifm.height=document.documentElement.clientHeight-250||400:ifm.height=200)</script></body></html><!-- rebuild by neat -->