<!-- build time:Wed Mar 06 2019 22:02:16 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="boxi"><meta name="google-site-verification" content="iOm73y6vS5qme_s6tWGOVE1l5iATBiNi7Ye7J4dv68g"><meta name="baidu-site-verification" content="9BXA7j00i6"><title>编写高质量JavaScript代码 · boxi's box</title><meta name="description" content="汇总《Effective JavaScript》68个有效方法。一、JavaScript特性第1条: JavaScript版本JavaScript在1997年正式成为国际标准(ECMAScript)，至今共经历了多个版本，如1999年定稿的ES3、2009年发布的ES5和2015年确定的ES6等，不"><meta name="keywords" content="技术积累, 生活感悟"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/img/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/img/logo@2x.png" style="width:150px"><h3><a href="/">boxi's box</a></h3><div class="description"><p>Poor Guy In Shenzhen</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2263667870"><i class="fa fa-weibo"></i></a></li><li><a href="http://facebook.com/boxi.zeng"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/boxizen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me">CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben </a><span>Edit by</span><a href="https://github.com/boxizen"> Boxi</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/photos">咔嚓</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>编写高质量JavaScript代码</a></h3></div><div class="post-content"><blockquote><p>汇总《Effective JavaScript》68个有效方法。</p></blockquote><h2 id="一、JavaScript特性"><a href="#一、JavaScript特性" class="headerlink" title="一、JavaScript特性"></a>一、JavaScript特性</h2><h3 id="第1条-JavaScript版本"><a href="#第1条-JavaScript版本" class="headerlink" title="第1条: JavaScript版本"></a><strong>第1条: JavaScript版本</strong></h3><p>JavaScript在1997年正式成为国际标准(ECMAScript)，至今共经历了多个版本，如1999年定稿的ES3、2009年发布的ES5和2015年确定的ES6等，不同平台上支持的版本有差异，因此确定当前运行环境所支持的ES版本至关重要。</p><p>ES5引入了一种版本控制的考量－严格模式(strict mode)，用于禁止使用一些JavaScript语言中问题较多或易于出错的特性，这种写法向后兼容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行函数代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第2条-JavaScript浮点数"><a href="#第2条-JavaScript浮点数" class="headerlink" title="第2条: JavaScript浮点数"></a><strong>第2条: JavaScript浮点数</strong></h3><p>不同于其他编程语言，JavaScript的数值型数据类型只有一种：双精度浮点数(double－由IEEE754标准制定的64位编码数字，可以表示高达53位精度的整数)，对于浮点数的运算应该时刻保持警惕，它们的运算并不精确，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>; <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>解决办法是尽可能地采用整数值运算，因为整数在表示时不需要摄入。</p><h3 id="第3条-隐式的强制转换"><a href="#第3条-隐式的强制转换" class="headerlink" title="第3条: 隐式的强制转换"></a><strong>第3条: 隐式的强制转换</strong></h3><p>JavaScript对类型错误出奇地/宽容，许多在其他动态类型语言中的表达式被认为是错误的，而在JavaScript中却可以正确地运行。<br>如算术运算符 -、 *、 / 和 ％ 在计算前会尝试将其参数转换为数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为NaN</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isReallyNaN</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x !== x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个对象存在toString()和valueOf()方法时，在执行+运算时默认调用的是valueOf()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'string method'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj: '</span> + obj); <span class="comment">// obj: 0</span></span><br></pre></td></tr></table></figure><p>JavaScript中有7个假值: false、0、－0、””、NaN、null和undefined，其他所有的值均为真值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数忽略任何为假值的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">   x = <span class="number">320</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!y) &#123;</span><br><span class="line">   y = <span class="number">240</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查参数是否为undefined更为严格的方式是使用typeof或者和undefined比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof判断</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">'undefined'</span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和undefined比较</span></span><br><span class="line"><span class="keyword">if</span>(x === <span class="literal">undefined</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="第4条-原始类型优于封装对象"><a href="#第4条-原始类型优于封装对象" class="headerlink" title="第4条: 原始类型优于封装对象"></a><strong>第4条: 原始类型优于封装对象</strong></h3><p>除了对象以外，JavaScript有5个原始值类型：布尔值、数字、字符串、null和undefined。</p><p>当作相等比较时，原始类型的封装对象与其原始值行为不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line">s1 === s2; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">'hello'</span>;</span><br><span class="line">s3 === s4; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>获取和设置原始类型值的属性会隐式地创建封装对象，因此对原始类型设置属性是没有意义的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.someProperty = <span class="number">17</span>;</span><br><span class="line"><span class="string">'hello'</span>.someProperty; <span class="comment">// undefined;</span></span><br></pre></td></tr></table></figure><h3 id="第5条-避免对混合类型使用-运算符"><a href="#第5条-避免对混合类型使用-运算符" class="headerlink" title="第5条: 避免对混合类型使用==运算符"></a><strong>第5条: 避免对混合类型使用==运算符</strong></h3><p>当参数类型不同时，＝＝运算符应用了一套难以理解的隐式强制类型转换规则，如下所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   参数类型<span class="number">1</span>    |  参数类型<span class="number">2</span>   |  强制转换 |</span><br><span class="line">| :-----------: | :-----------:  | :-------: |</span><br><span class="line">| <span class="literal">null</span>| <span class="literal">undefined</span>| 不转换，总是返回<span class="literal">true</span>|</span><br><span class="line">| <span class="literal">null</span>或<span class="literal">undefined</span> | 其他任何非<span class="literal">null</span>或<span class="literal">undefined</span>的类型 | 不转换，总是返回<span class="literal">false</span> |</span><br><span class="line">| 原始类型: string、number或boolean | <span class="built_in">Date</span>对象 | 原始类型转换为数字；<span class="built_in">Date</span>对象转换为原始类型(优先尝试toString，再尝试valueOf) |</span><br><span class="line">| 原始类型: string、number或boolean | 非<span class="built_in">Date</span>对象 | 原始类型转换为数字；将非<span class="built_in">Date</span>对象转换为原始类型(优先尝试valueOf，再尝试toString) |</span><br><span class="line">| 原始类型: string、number或boolean | 原始类型: string、number或boolean | 将原始类型转换为数字 |</span><br></pre></td></tr></table></figure><p>==运算符应用的转换规则难以理解，在比较不同类型的值时，可使用显示强制转换使程序的行为更为清晰。</p><h3 id="第6条-了解分号插入的局限"><a href="#第6条-了解分号插入的局限" class="headerlink" title="第6条: 了解分号插入的局限"></a><strong>第6条: 了解分号插入的局限</strong></h3><p>在以 ( 、 [ 、 + 、 － 、 或 / 字符开头的语句前绝不能省略分号。</p><p>当脚本连接的时候，在脚本之间显示地插入分号。</p><p>在return、throw、break、continue、++或–的参数之前不能换行。</p><h3 id="第7条-视字符串为16位的代码单元序列"><a href="#第7条-视字符串为16位的代码单元序列" class="headerlink" title="第7条: 视字符串为16位的代码单元序列"></a><strong>第7条: 视字符串为16位的代码单元序列</strong></h3><p>略</p><h2 id="二、变量作用域"><a href="#二、变量作用域" class="headerlink" title="二、变量作用域"></a>二、变量作用域</h2><h3 id="第8、9条-尽量少用全局对象，始终声明局部变量"><a href="#第8、9条-尽量少用全局对象，始终声明局部变量" class="headerlink" title="第8、9条: 尽量少用全局对象，始终声明局部变量"></a><strong>第8、9条: 尽量少用全局对象，始终声明局部变量</strong></h3><p>在JavaScript中，定义全局变量会污染共享的公共命名空间，并可能导致意外的命名冲突。全局变量不利于模块化，因为它会导致程序中独立组件间的不必要耦合</p><p>因此应该尽可能避免声明全局变量，转而使用局部变量取代。</p><h3 id="第10条-避免使用with"><a href="#第10条-避免使用with" class="headerlink" title="第10条: 避免使用with"></a><strong>第10条: 避免使用with</strong></h3><p>程序经常需要对单个对象依次调用一系列方法，<strong>with</strong>语句的动机在于方便地避免对对象的重复引用，而这种方便却是以不可靠和低效率为代价的。</p><p>在with语句中使用某变量时，虽然会在with对象的作用域中查找是否存在该变量，如果存在，则使用with对象中的变量，否则会在上一层作用域中查找该变量，这种做法导致了变量容易混淆和查找效率低两种后果。</p><p>因此应该尽可能避免使用with语句，可通过<strong>使用简单的变量名代替重复访问的对象</strong>和<strong>显示绑定局部变量到对象属性上</strong>两种方式取代with语句。</p><p><strong>变量名代替重复访问的对象:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">status</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> w = <span class="keyword">new</span> Widget();</span><br><span class="line">  w.setBackground(<span class="string">'blue'</span>);</span><br><span class="line">  w.setForeground(<span class="string">'white'</span>);</span><br><span class="line">  w.addText(<span class="string">'status:'</span> + info);</span><br><span class="line">  w.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显示绑定局部变量到对象属性上:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min = <span class="built_in">Math</span>.min, round = <span class="built_in">Math</span>.round, sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line">  <span class="keyword">return</span> min(round(x), sqrt(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第11条-熟练使用闭包"><a href="#第11条-熟练使用闭包" class="headerlink" title="第11条: 熟练使用闭包"></a><strong>第11条: 熟练使用闭包</strong></h3><p>闭包是JavaScript中的特性，有如下三个特点：</p><p><strong>1. 允许引用在当前函数外定义的变量:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSandwich</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> magicIngredient = <span class="string">'peanut butter'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> magicIngredient + <span class="string">' and '</span> + filling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make(<span class="string">'jelly'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sandwichMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> magicIngredient = <span class="string">'peanut butter'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> magicIngredient + <span class="string">' and '</span> + filling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> make;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = sandwichMaker();</span><br><span class="line">f(<span class="string">'jelly'</span>);</span><br></pre></td></tr></table></figure><p><strong>3. 闭包可以更新外部变量的值:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> val = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  val = newVal;</span><br><span class="line">   &#125;,</span><br><span class="line">   get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">   &#125;,</span><br><span class="line">   type: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = box();</span><br><span class="line">b.type(); <span class="comment">// undefined;</span></span><br><span class="line">b.set(<span class="number">98.6</span>);</span><br><span class="line">b.get(); <span class="comment">// 98.6</span></span><br><span class="line">b.type(); <span class="comment">// 'number'</span></span><br></pre></td></tr></table></figure><h3 id="第12条-理解变量声明提升"><a href="#第12条-理解变量声明提升" class="headerlink" title="第12条: 理解变量声明提升"></a><strong>第12条: 理解变量声明提升</strong></h3><p>在代码块中的变量声明会被隐式地提升到封闭函数的顶部，我们称之为<strong>变量提升</strong>。</p><p>需要注意的是JavaScript没有块级作用域，但其中一个例外是<strong>try-catch</strong>语句:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'var'</span>, result = [];</span><br><span class="line">  result.push(x);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">'exception'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(x) &#123;</span><br><span class="line"> x = <span class="string">'catch'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result.push(x);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// ['var', 'var']</span></span><br></pre></td></tr></table></figure><h3 id="第13条-使用立即调用的函数表达式创建局部作用域"><a href="#第13条-使用立即调用的函数表达式创建局部作用域" class="headerlink" title="第13条: 使用立即调用的函数表达式创建局部作用域"></a><strong>第13条: 使用立即调用的函数表达式创建局部作用域</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapElements</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [], i, n;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>, n = a.length; i &lt; n; i++) &#123;</span><br><span class="line"> result[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a[i];</span><br><span class="line"> &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> w = wrapElements([<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">43</span>]);</span><br><span class="line">w[<span class="number">0</span>]; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="第16条-避免使用eval创建局部变量"><a href="#第16条-避免使用eval创建局部变量" class="headerlink" title="第16条: 避免使用eval创建局部变量"></a><strong>第16条: 避免使用eval创建局部变量</strong></h3><p>eval函数容易污染调用者的作用域，如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x) &#123;</span><br><span class="line"> <span class="built_in">eval</span>(<span class="string">'var y = "local";'</span>); <span class="comment">// 动态绑定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">true</span>); <span class="comment">// local</span></span><br><span class="line">test(<span class="literal">false</span>); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><p>保证eval函数不影响外部作用域的一个方法是在一个明确的嵌套作用域中运行它，如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">eval</span>(src);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'var y = "local";'</span>); <span class="comment">// global</span></span><br><span class="line">test(<span class="string">'var z = "local";'</span>); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><h3 id="第17条-间接调用eval函数优于直接调用"><a href="#第17条-间接调用eval函数优于直接调用" class="headerlink" title="第17条: 间接调用eval函数优于直接调用"></a><strong>第17条: 间接调用eval函数优于直接调用</strong></h3><h2 id="三、使用函数"><a href="#三、使用函数" class="headerlink" title="三、使用函数"></a>三、使用函数</h2><h3 id="第18条-函数调用、方法调用及构造函数调用区别"><a href="#第18条-函数调用、方法调用及构造函数调用区别" class="headerlink" title="第18条: 函数调用、方法调用及构造函数调用区别"></a><strong>第18条: 函数调用、方法调用及构造函数调用区别</strong></h3><p>有别于其他面向对象编程语言，JavaScript 将函数调用、方法调用以及构造函数调用看作是单个构造对象的三种不同的使用模式。</p><h3 id="第19条-熟练掌握高阶函数"><a href="#第19条-熟练掌握高阶函数" class="headerlink" title="第19条: 熟练掌握高阶函数"></a><strong>第19条: 熟练掌握高阶函数</strong></h3><p>所谓高阶函数，即是使用函数作为<strong>参数</strong>或<strong>返回值</strong>的函数，常常用于数组的方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">"ABC"</span>, <span class="string">"dEf"</span>, <span class="string">"GHI"</span>];</span><br><span class="line"><span class="keyword">var</span> lower = names.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.toLowerCase();</span><br><span class="line">&#125;)</span><br><span class="line">lower; <span class="comment">// ['abc', 'def', 'ghi']</span></span><br></pre></td></tr></table></figure><p>此外，高阶函数还可用于重构并整合一些相同的模式，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alphabet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> aIndex = <span class="string">"a"</span>.charCodeAt(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> alphabet = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    alphabet += <span class="built_in">String</span>.fromCharCode(aIndex + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">digits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> digits = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    digits += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> random = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    random += <span class="built_in">String</span>.fromCharCode(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">26</span>) + aIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个函数创建了不同的字符串，但是他们都有着共同的逻辑，可以通过编写一个高阶函数提取出共用的部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildString</span>(<span class="params">n, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result += callback(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是上面的三个例子可以简化为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alphabet = buildString(<span class="number">26</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(alIndex + i);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> digits = buildString(<span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> random = buildString(<span class="number">8</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">String</span>.fromCharCode(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">26</span>)+ aIndex);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第20条-使用call调用方法"><a href="#第20条-使用call调用方法" class="headerlink" title="第20条: 使用call调用方法"></a><strong>第20条: 使用call调用方法</strong></h3><p>在很多业务场景下，开发者常常需要自定义对象作为某个函数的调用者，首先想到的方法可能是将该函数作为一个新的属性添加到接受者对象中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.temporary = f;</span><br><span class="line"><span class="keyword">var</span> result = obj.temporary(arg1, arg2, arg3);</span><br><span class="line"><span class="keyword">delete</span> obj.temporay;</span><br></pre></td></tr></table></figure><p>然而这种方法看上去非常别扭而危险，一般而言这种做法是一种不好的实践，可通过 call 解决这样的问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(obj, arg1, arg2, arg3);</span><br></pre></td></tr></table></figure><h3 id="第21条-使用apply调用方法"><a href="#第21条-使用apply调用方法" class="headerlink" title="第21条: 使用apply调用方法"></a><strong>第21条: 使用apply调用方法</strong></h3><p>apply 与 call 类似，区别在于 apply 接收的参数对象为数组对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = getAllScores();</span><br><span class="line">average.apply(<span class="literal">null</span>, scores);</span><br></pre></td></tr></table></figure><h3 id="第22-24条-arguments对象"><a href="#第22-24条-arguments对象" class="headerlink" title="第22-24条: arguments对象"></a><strong>第22-24条: arguments对象</strong></h3><p>隐式的 arguments 对象可实现可变参数的函数，虽然 arguments 看起来像一个数组，但它并不是一个真正的数组，可通过下面的方法将它转化为真正的数组:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="第25-26条-使用bind方法"><a href="#第25-26条-使用bind方法" class="headerlink" title="第25-26条: 使用bind方法"></a><strong>第25-26条: 使用bind方法</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = &#123;</span><br><span class="line">  entries: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.entries.push(s);</span><br><span class="line">  &#125;,</span><br><span class="line">  concat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.entries.join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">buffer.add.bind(buffer); <span class="comment">//绑定buffer对象为函数接受者</span></span><br></pre></td></tr></table></figure><h3 id="第28条-不要信赖函数对象的toString方法"><a href="#第28条-不要信赖函数对象的toString方法" class="headerlink" title="第28条: 不要信赖函数对象的toString方法"></a><strong>第28条: 不要信赖函数对象的toString方法</strong></h3><p>通常情况下，应该避免使用函数对象的 toString 方法。</p><h3 id="第29条-避免使用非标准的栈检查属性"><a href="#第29条-避免使用非标准的栈检查属性" class="headerlink" title="第29条: 避免使用非标准的栈检查属性"></a><strong>第29条: 避免使用非标准的栈检查属性</strong></h3><p>避免使用非标准的 arguments.caller 和 arguments.callee 属性</p><h2 id="四、对象和原型"><a href="#四、对象和原型" class="headerlink" title="四、对象和原型"></a>四、对象和原型</h2><h3 id="第30条-理解prototype、getPrototype和proto之间的不同"><a href="#第30条-理解prototype、getPrototype和proto之间的不同" class="headerlink" title="第30条: 理解prototype、getPrototype和proto之间的不同"></a><strong>第30条: 理解prototype、getPrototype和<strong>proto</strong>之间的不同</strong></h3><ul><li>C.prototype 属性是 new C() 创建的对象的原型。</li><li>Object.getPrototypeOf(obj) 是 ES5 中检索对象原型的标准函数。</li><li>obj.<strong>proto</strong> 是检索对象原型的非标准方法。</li><li>类是由一个构造函数和一个关联的原型组成的一种设计模式。</li></ul><h3 id="第31条-使用getPrototypeOf函数代替proto属性"><a href="#第31条-使用getPrototypeOf函数代替proto属性" class="headerlink" title="第31条: 使用getPrototypeOf函数代替proto属性"></a><strong>第31条: 使用getPrototypeOf函数代替<strong>proto</strong>属性</strong></h3><p>ES5 引入 Object.getPrototypeOf 函数作为获取对象原型的标准 API，而在此之前大量的 JavaScript 引擎使用 <strong>proto</strong> 属性达到相同的目的，但由于该属性并不是完全兼容</p><h3 id="第32条-始终不要修改proto属性"><a href="#第32条-始终不要修改proto属性" class="headerlink" title="第32条: 始终不要修改proto属性"></a><strong>第32条: 始终不要修改<strong>proto</strong>属性</strong></h3><ul><li>始终不要修改对象的 <strong>proto</strong> 属性。</li><li>使用 Object.create 函数给新对象设置自定义的原型</li></ul><h3 id="第34条-在原型中存储方法"><a href="#第34条-在原型中存储方法" class="headerlink" title="第34条: 在原型中存储方法"></a><strong>第34条: 在原型中存储方法</strong></h3><p>将方法存储在实例对象中会创建该函数的多个副本，因为每个实例对象都有一份副本，将方法存储于原型中优于存储在实例对象。</p><h3 id="第37-this变量的隐式绑定"><a href="#第37-this变量的隐式绑定" class="headerlink" title="第37 this变量的隐式绑定"></a><strong>第37 this变量的隐式绑定</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CSVReader.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = str.trim().split(<span class="regexp">/\n/</span>);</span><br><span class="line">    <span class="keyword">return</span> lines.map(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="keyword">this</span>.regexp);</span><br><span class="line">  &#125;,<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSVReader.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = str.trim().split(<span class="regexp">/\n/</span>);</span><br><span class="line">    <span class="keyword">return</span> lines.map(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="keyword">this</span>.regexp);</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-04-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/前端/" title="前端">前端 </a><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript</a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://boxizen.github.io/2016/04/05/effective_javascript/,boxi's box,编写高质量JavaScript代码,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2016/09/11/electron/" title="Electron 构建跨平台桌面应用">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/02/14/javascript_summarize/" title="JavaScript知识梳理">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine=new Valine({el:"#vcomments",notify:!0,verify:!1,app_id:"bUTfY8SwOBitSS8uqiV0vG0I-gzGzoHsz",app_key:"N6bRxFzuVXEBBdX96fGb1i4e",placeholder:"来，一起快活",path:window.location.pathname,avatar:"monsterid"})</script></div></div></div></div><script src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1274080808'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s13.cnzz.com/z_stat.php%3Fid%3D1274080808%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">var ifm=document.getElementById("iframe");ifm&&($(window).width()>500?ifm.height=document.documentElement.clientHeight-250||400:ifm.height=200)</script></body></html><!-- rebuild by neat -->